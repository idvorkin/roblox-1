<roblox version="4">
  <Item class="ReplicatedFirst" referent="0">
    <Properties>
      <string name="Name">ReplicatedFirst</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Aero</string>
      </Properties>
      <Item class="LocalScript" referent="2">
        <Properties>
          <string name="Name">AeroLoad</string>
          <string name="Source"><![CDATA[--[[
	
	At its heart, the way to wait for the AeroGameFramework to
	load is to simply wait for it to exist in the _G table:
	
		while (not _G.Aero) do wait() end
		local aero = _G.Aero
	
	
	The following code shows how to do this with a custom GUI,
	but you will have to fill in some of the code yourself.

	IF YOU USE THIS CODE, MAKE SURE TO PUT IT IN A FILE NAMED 
	SOMETHING OTHER THAN 'AeroLoad' SO FUTURE FRAMEWORK UPDATES 
	DO NOT OVERWRITE YOUR CUSTOM 'AeroLoad' SCRIPT. YOU CAN NAME 
	IT ANYTHING, LIKE 'MyCustomAeroLoad'
	
]]

--[[  UNCOMMENT TO USE THIS TEMPLATE (BUT BE SURE TO ADD YOUR OWN GUI ON LINE 47)

local player = game.Players.LocalPlayer

-- Temporary blackout used until the Aero Fade module is loaded:
local tempBlackout = Instance.new("ScreenGui")
tempBlackout.Name = "TemporaryBlackout"
tempBlackout.DisplayOrder = 10
do
	local frame = Instance.new("Frame")
	frame.Name = "Overlay"
	frame.AnchorPoint = Vector2.new(0.5, 0.5)
	frame.Size = UDim2.new(2, 0, 2, 0)
	frame.BackgroundColor3 = Color3.new(0, 0, 0)
	frame.Parent = tempBlackout
end

-- Remove default loading screen & replace with a temporary black overlay:
tempBlackout.Parent = player:WaitForChild("PlayerGui")
game:GetService("ReplicatedFirst"):RemoveDefaultLoadingScreen()

-- Wait for the Aero client to load:
while (not _G.Aero) do wait() end
local aero = _G.Aero

-- Make screen black using the Aero Fade module:
aero.Controllers.Fade:Out(0)

-- Remove the temporary overlay, since we don't need it anymore:
tempBlackout:Destroy()

-- Add in your own loading screen GUI:
local loadingGui = script.YOUR_CUSTOM_GUI
loadingGui.Parent = player:WaitForChild("PlayerGui")

-- Fade in slowly to show your loading screen:
aero.Controllers.Fade:In(1)

-- Wait for the game to load if not loaded yet:
if (not game:IsLoaded()) then
	game.Loaded:Wait()
end

-- INSERT OTHER LOADING THINGS HERE
-- EXAMPLE: game:GetService("ContentProvider"):PreloadAsync({foo, bar, etc})

-- Fade out to black, remove your GUI, and then fade back in:
wait(3)
aero.Controllers.Fade:Out(1)
loadingGui:Destroy()
aero.Controllers.Fade:In(1)

]]
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ReplicatedStorage" referent="3">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="4">
      <Properties>
        <string name="Name">Aero</string>
      </Properties>
      <Item class="Folder" referent="5">
        <Properties>
          <string name="Name">Internal</string>
        </Properties>
        <Item class="ModuleScript" referent="6">
          <Properties>
            <string name="Name">Settings</string>
            <string name="Source">-- Settings
-- Stephen Leitnick
-- August 25, 2020

--[[

	Settings.InternalSettings {
		DefaultOrder: number
	}

	Settings:Get(moduleScript) -> table
	Settings:GetDefault() -> table
	Settings:IsSettingsModule(moduleScript) -> boolean

--]]



local Settings = {}

Settings.InternalSettings = {
	DefaultOrder = 1000;
}

local SUFFIX = ".settings"
local DEFAULT_SETTINGS = {
	Order = Settings.InternalSettings.DefaultOrder;
	PreventInit = false;
	PreventStart = false;
	Standalone = false;
}

local cache = {}


function Settings:GetDefault()
	-- Make a copy of the default settings table:
	local s = {}
	for k,v in pairs(DEFAULT_SETTINGS) do
		s[k] = v
	end
	return s
end


function Settings:Get(moduleScript, shouldCache)

	local settingsName = (moduleScript.Name .. SUFFIX)
	local settingsTbl = cache[settingsName]

	-- Return from cache if found:
	if (settingsTbl) then
		return settingsTbl
	end

	-- Find the actual settings module:
	local settingsModule = moduleScript.Parent:FindFirstChild(settingsName)

	-- Load settings module if available, or else load default settings:
	if (settingsModule) then
		settingsTbl = require(settingsModule)
		assert(type(settingsTbl) == "table", "Settings module should return a table")
	else
		settingsTbl = self:GetDefault()
	end

	-- Cache if requested:
	if (shouldCache) then
		cache[settingsName] = settingsTbl
	end

	return settingsTbl

end


function Settings:IsSettingsModule(moduleScript)
	return (moduleScript:IsA("ModuleScript") and moduleScript.Name:match(SUFFIX .. "$") ~= nil)
end


return Settings</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="7">
        <Properties>
          <string name="Name">Shared</string>
        </Properties>
        <Item class="ModuleScript" referent="8">
          <Properties>
            <string name="Name">Base64</string>
            <string name="Source"><![CDATA[--- Base64
-- Encodes and decodes values to and from Base64
-- @author antifragileer <https://www.roblox.com/users/443282130/profile>
-- @see Developed for the Aero Game Framework <https://github.com/Sleitnick/AeroGameFramework>
-- @see Adapted from https://github.com/toastdriven/lua-base64 for the Roblox game.
-- @see Re-adapted from https://gist.github.com/howmanysmall/016a35f0debcfb81f14e6bee03d450de and https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2.
-- @license BSD
-- July 15, 2018

--[[
	
	local base64 = Base64.new()
	
	Example:
	
	local myEncodedWord = base64:Encode("Hello")
	
	print(myEncodedWord)
	
	-- outputs: SGVsbG8=
	
	print(base64:Decode(myEncodedWord))
	
	-- outputs: Hello

--]]

local Alphabet = {}
local Indexes = {}

for Index = 65, 90 do table.insert(Alphabet, Index) end -- A-Z
for Index = 97, 122 do table.insert(Alphabet, Index) end -- a-z
for Index = 48, 57 do table.insert(Alphabet, Index) end -- 0-9

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {
	ClassName = "Base64";
	__tostring = function(self) return self.ClassName end;
}

Base64.__index = Base64

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

function Base64.new()
	return setmetatable({}, Base64)
end

--[[**
	Encodes a string in Base64.
	@param [string] Input The input string to encode.
	@returns [string] The string encoded in Base64.
**--]]
function Base64:Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Output[Length + 1] = Alphabet[A + 1]
		Output[Length + 2] = Alphabet[B + 1]
		Output[Length + 3] = C2 and Alphabet[C + 1] or 61
		Output[Length + 4] = C3 and Alphabet[D + 1] or 61
		Length = Length + 4
	end

	local NewOutput = {}
	local NewLength = 0

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		NewOutput[NewLength] = string.char(table.unpack(Output, Index, math.min(Index + 4096 - 1, Length)))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [string] Input The input string to decode.
	@returns [string] The newly decoded string.
**--]]
function Base64:Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A
		if C3 ~= 61 then Length = Length + 1 Output[Length] = B end
		if C4 ~= 61 then Length = Length + 1 Output[Length] = C end
	end

	local NewOutput = {}
	local NewLength = 0

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		NewOutput[NewLength] = string.char(table.unpack(Output, Index, math.min(Index + 4096 - 1, Length)))
	end

	return table.concat(NewOutput)
end

return Base64
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">Date</string>
            <string name="Source">-- Date
-- Stephen Leitnick
-- September 12, 2017

--[=[

	Represents a date at a specific time. On the server, this will
	return UTC time. On the client, this will return local time.
	Note that the server-side in Play-Solo testing will also return
	local time.

	You can optionally force UTC within the Date.new constructor.


	REQUIRE:

		local Date = require(thisModule)

	
	CONSTRUCTORS:

		local date = Date.new([seconds [, useUtc]])
		local date = Date.fromJSON(jsonString)


	METHODS:

		date:ToJSON()
		date:ToSeconds()
		date:GetTimezoneHourOffset()
		date:Format(strFormat)
		date:ToUTC()
		date:ToLocal()
		date:ToISOString()
		date:ToDateString()
		date:ToTimeString()
		date:ToString()


	PROPERTIES:

		date.Hour
		date.Minute
		date.Weekday
		date.Day
		date.Month
		date.Year
		date.Second
		date.Millisecond
		date.Yearday
		date.IsDST


	NOTE ON SAVING:

		You should use 'date:ToSeconds()' for saving. It can
		represent the date in the smallest format. While using
		'date:ToJSON()' will work too, it has a higher data
		footprint. Example:

		SAVE:

			local date = Date.new()
			dataStore:SetAsync("myDate", date:ToSeconds())

		LOAD:

			local myDateSeconds = dataStore:GetAsync("myDate")
			local date = Date.new(myDateSeconds)

	

--]=]



local Date = {}
Date.__index = Date


local useUTC = game:GetService("RunService"):IsServer()


local WEEKDAYS = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}
local WEEKDAYS_SHORT = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

local MONTHS = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
local MONTHS_SHORT = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}


-- Single-level table copy:
local function CopyTable(t)
	local tCopy = {}
	for k,v in pairs(t) do
		tCopy[k] = v
	end
	return tCopy
end


function Date.new(seconds, useUtcOverride)

	if (seconds ~= nil) then
		assert(type(seconds) == "number", "'seconds' argument #1 must be a number")
	else
		seconds = tick()
	end

	local utc = useUTC
	if (useUtcOverride ~= nil) then
		utc = useUtcOverride
	end

	local d = os.date(utc and "!*t" or "*t", seconds)

	local self = setmetatable({
		Hour = d.hour;
		Minute = d.min;
		Weekday = d.wday;
		Day = d.day;
		Month = d.month;
		Year = d.year;
		Second = d.sec;
		Millisecond = math.floor((seconds % 1) * 1000);
		Yearday = d.yday;
		IsDST = d.isdst;
		_d = d;
		_s = seconds;
	}, Date)

	return self

end


function Date.fromJSON(jsonStr)
	assert(type(jsonStr) == "string", "'jsonStr' argument #1 must be a string")
	local success, data = pcall(function()
		return game:GetService("HttpService"):JSONDecode(jsonStr)
	end)
	if (not success) then
		error("Failed to decode JSON string: " .. tostring(data))
	end
	local seconds
	if (data._s) then
		seconds = data._s
	else
		seconds = os.time(data)
	end
	return Date.new(seconds)
end


function Date:ToJSON()
	local data = CopyTable(self._d)
	data._s = self._s
end


function Date:ToSeconds()
	return self._s
end


function Date:GetTimezoneHourOffset()
	local dUTC = os.date("!*t", self._s)
	return (self._d.hour - dUTC.hour)
end


function Date:ToISOString()
	local utc = self:ToUTC()
	local d = utc._d
	return ("%.2i-%.2i-%.2iT%.2i:%.2i:%.2i.%.3i"):format(
		d.year,
		d.month,
		d.day,
		d.hour,
		d.min,
		d.sec,
		math.floor((utc._s % 1) * 1000)
	)
end


function Date:ToDateString()
	local d = self._d
	return ("%s %s %i %i"):format(
		WEEKDAYS_SHORT[d.wday],
		MONTHS_SHORT[d.month],
		d.day,
		d.year
	)
end


function Date:ToTimeString()
	local d = self._d
	return ("%.2i:%.2i:%.2i"):format(
		d.hour,
		d.min,
		d.sec
	)
end


function Date:ToString()
	return (self:ToDateString() .. " " .. self:ToTimeString())
end


function Date:ToUTC()
	return Date.new(self._s, true)
end


function Date:ToLocal()
	return Date.new(self._s, false)
end


-- See GNU date commands:
-- https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/
function Date:Format(str)
	local d = self._d
	local h12 = d.hour
	if (h12 > 12) then
		h12 = h12 - 12
	end
	if (h12 == 0) then
		h12 = 0
	end
	str = str
		:gsub("%%a", WEEKDAYS_SHORT[d.wday])
		:gsub("%%A", WEEKDAYS[d.wday])
		:gsub("%%b", MONTHS_SHORT[d.month])
		:gsub("%%B", MONTHS[d.month])
		:gsub("%%c", self:ToString())
		:gsub("%%C", ((d.year - (d.year % 1000)) / 100) + 1)
		:gsub("%%d", ("%.2i"):format(d.day))
		:gsub("%%D", ("%.2i/%.2i/%s"):format(d.month, d.day, tostring(d.year):sub(-2)))
		:gsub("%%F", ("%i-%.2i-%.2i"):format(d.year, d.month, d.day))
		:gsub("%%H", ("%.2i"):format(d.hour))
		:gsub("%%k", ("%.2i"):format(d.hour))
		:gsub("%%I", ("%.2i"):format(h12))
		:gsub("%%l", ("%.2i"):format(h12))
		:gsub("%%j", ("%.3i"):format(d.yday))
		:gsub("%%m", ("%.2i"):format(d.month))
		:gsub("%%M", ("%.2i"):format(d.min))
		:gsub("%%n", "\n")
		:gsub("%%p", (d.hour >= 12 and "PM" or "AM"))
		:gsub("%%P", (d.hour >= 12 and "pm" or "am"))
		:gsub("%%r", ("%.2i:%.2i:%.2i %s"):format(h12, d.min, d.sec, (d.hour >= 12 and "PM" or "AM")))
		:gsub("%%R", ("%.2i:%.2i"):format(d.hour, d.min))
		:gsub("%%s", math.floor(self._s))
		:gsub("%%S", ("%.2i"):format(d.sec))
		:gsub("%%t", "\t")
		:gsub("%%T", ("%.2i:%.2i:%.2i"):format(d.hour, d.min, d.sec))
		:gsub("%%w", ("%.2i"):format(d.wday))
		:gsub("%%y", tostring(d.year):sub(-2))
		:gsub("%%Y", tostring(d.year))
	return str

end


Date.New = Date.new
Date.FromJSON = Date.fromJSON
Date.__tostring = Date.ToString
Date.__metatable = "locked"


function Date.__lt(d1, d2)
	return (d1._s &lt; d2._s)
end


function Date.__le(d1, d2)
	return (d1._s &lt;= d2._s)
end


function Date.__eq(d1, d2)
	return (d1._s == d2._s)
end


function Date.__unm(d)
	return Date.new(-d._s)
end


return Date</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">ListenerList</string>
            <string name="Source">-- Listener List
-- Stephen Leitnick
-- November 1, 2015

--[[
	
	local listeners = ListenerList.new()
	
	listeners:Connect(event, func)
	listeners:BindToRenderStep(name, priority, func)
	listeners:BindAction(actionName, funcToBind, createTouchBtn [, inputTypes...])
	listeners:BindActionAtPriority(actionName, funcToBind, createTouchBtn, priorityLevel [, inputTypes...])

	listeners:DisconnectAll()
	listeners:DisconnectEvents()
	listeners:DisconnectRenderSteps()
	listeners:DisconnectActions()

	listeners:Destroy()
		> Alias for DisconnectAll
	
--]]



local ListenerList = {}
ListenerList.__index = ListenerList


function ListenerList.new()
	local self = setmetatable({
		_listeners = {};
		_renderStepNames = {};
		_actionNames = {};
	}, ListenerList)
	return self
end


-- Connect a function to an event and store it in the list:
function ListenerList:Connect(event, func)
	local listener = event:Connect(func)
	table.insert(self._listeners, listener)
	return listener
end


function ListenerList:BindToRenderStep(name, ...)
	table.insert(self._renderStepNames, name)
	game:GetService("RunService"):BindToRenderStep(name, ...)
end


function ListenerList:BindAction(name, ...)
	table.insert(self._actionNames, name)
	game:GetService("ContextActionService"):BindAction(name, ...)
end


function ListenerList:BindActionAtPriority(name, ...)
	table.insert(self._actionNames, name)
	game:GetService("ContextActionService"):BindActionAtPriority(name, ...)
end


function ListenerList:DisconnectEvents()
	for _,l in ipairs(self._listeners) do
		if (l.Connected) then
			l:Disconnect()
		end
	end
	self._listeners = {}
end


function ListenerList:DisconnectRenderSteps()
	local runService = game:GetService("RunService")
	for _,n in ipairs(self._renderStepNames) do
		runService:UnbindFromRenderStep(n)
	end
	self._renderStepNames = {}
end


function ListenerList:DisconnectActions()
	local ctxService = game:GetService("ContextActionService")
	for _,n in ipairs(self._actionNames) do
		ctxService:UnbindAction(n)
	end
	self._actionNames = {}
end


-- Disconnect all events in the list and clear the list:
function ListenerList:DisconnectAll()
	self:DisconnectEvents()
	self:DisconnectRenderSteps()
	self:DisconnectActions()
end


ListenerList.Destroy = ListenerList.DisconnectAll


return ListenerList</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">Maid</string>
            <string name="Source">-- Maid
-- Author: Quenty
-- Source: https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Events/Maid.lua
-- License: MIT (https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md)
-- This module has been modified for use in AeroGameFramework

--[[

	maid = Maid.new()

	maid:GiveTask(task)
		> task is an event connection, function, or instance/table with a 'Destroy' method

	maid:GivePromise(promise)
	
	maid:DoCleaning()
		> Alias for Destroy
	
	maid:Destroy()
		> Goes through each task &amp; disconnects events, destroys instances, and calls functions

--]]

---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

local Promise


--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = setmetatable({
		_tasks = {};
	}, Maid)
	return self
end


--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if (Maid[index]) then
		return Maid[index]
	else
		return self._tasks[index]
	end
end


--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if (Maid[index] ~= nil) then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if (oldTask) then
		if (type(oldTask) == "function") then
			oldTask()
		elseif (typeof(oldTask) == "RBXScriptConnection") then
			oldTask:Disconnect()
		elseif (oldTask.Destroy) then
			oldTask:Destroy()
		end
	end
end


--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = (#self._tasks + 1)
	self[taskId] = task

	if (type(task) == "table" and (not task.Destroy)) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end


function Maid:GivePromise(promise)
	if (promise:GetStatus() ~= Promise.Status.Started) then
		return promise
	end

	local newPromise = Promise.Resolve(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end


--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if (typeof(task) == "RBXScriptConnection") then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while (task ~= nil) do
		tasks[index] = nil
		if (type(task) == "function") then
			task()
		elseif (typeof(task) == "RBXScriptConnection") then
			task:Disconnect()
		elseif (task.Destroy) then
			task:Destroy()
		end
		index, task = next(tasks)
	end
end


function Maid:Init()
	Promise = self.Shared.Promise
end


--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">NumberUtil</string>
            <string name="Source">-- Number Util
-- Stephen Leitnick
-- April 22, 2020

--[[

	NumberUtil.E
	NumberUtil.Tau

	NumberUtil.Lerp(min, max, alpha)
	NumberUtil.LerpClamp(min, max, alpha)
	NumberUtil.InverseLerp(min, max, num)
	NumberUtil.Map(num, inMin, inMax, outMin, outMax)
	NumberUtil.Round(num)
	NumberUtil.RoundTo(num, multiple)


	EXAMPLES:

		Lerp:

			Interpolate between two numbers by a certain alpha/percentage.

			Visually, think of a number line ranging from 'min' to 'max'
			and then move along that line by 'alpha' percent.

			Lerp(5, 15, 0.5) == 10
			Lerp(5, 15, 0)   == 5
			Lerp(5, 15, 0.7) == 12
			Lerp(5, 15, 2)   == 25  (unusual to have alpha outside of 0-1. See LerpClamp.)


		LerpClamp:

			The same as Lerp, but the 'alpha' value is clamped between 0-1,
			which will guarantee that the output is within bounds of the
			min and max values.

			LerpClamp(5, 15, 0.5) == 10
			LerpClamp(5, 15, 2)   == 15  (alpha of 2 was clamped down to 1)


		InverseLerp:

			The inverse of the Lerp function. It returns the alpha value
			between the range of [min, max] given the number.

			InverseLerp(5, 15, 10) == 0.5
			InverseLerp(5, 15, 12) == 0.7

		Map:

			Remaps the range of 'num' from its old range of [inMin, inMax]
			to a new range of [outMin, outMax]. This is useful when needing
			to convert a range of inputs to a different output. For instance,
			remapping gamepad stick input to a larger range controlling a
			vehicle steering wheel.

			Map(0.5, 0, 1, -10, 10) == 0
			Map(1, -1, 1, 0, 5)     == 5


		Round:

			Rounds a number to the nearest whole number.

			Round(1.5)  == 2
			Round(3.2)  == 3
			Round(-0.5) == -1


		RoundTo:

			Rounds a number to the nearest given multiple. An example would be
			locking world positions onto a larger grid.

			RoundTo(3.4, 5) == 5
			RoundTo(12, 5)  == 10

--]]


local NumberUtil = {}


NumberUtil.E = 2.7182818284590
NumberUtil.Tau = math.pi * 2


function NumberUtil.Lerp(min, max, alpha)
	return (min + ((max - min) * alpha))
end


function NumberUtil.LerpClamp(min, max, alpha)
	return NumberUtil.Lerp(min, max, math.clamp(alpha, 0, 1))
end


function NumberUtil.InverseLerp(min, max, num)
	return ((num - min) / (max - min))
end


function NumberUtil.Map(n, inMin, inMax, outMin, outMax)
	return (outMin + ((outMax - outMin) * ((n - inMin) / (inMax - inMin))))
end


function NumberUtil.Round(num)
	return (num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5))
end


function NumberUtil.RoundTo(num, multiple)
	return NumberUtil.Round(num / multiple) * multiple
end


return NumberUtil</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">Promise</string>
            <string name="Source">--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "No traceback")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end
Promise.Defer = Promise.defer

-- Backwards compatibility
Promise.async = Promise.defer
Promise.Async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end
Promise.Resolve = Promise.resolve

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end
Promise.Reject = Promise.reject

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end
Promise.Try = Promise.try

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount &lt; amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end
Promise.All = Promise.all

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end
Promise.Some = Promise.some

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end
Promise.Any = Promise.any

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end
Promise.AllSettled = Promise.allSettled

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end
Promise.Race = Promise.race

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end
Promise.Each = Promise.each

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end
Promise.Is = Promise.is

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end
Promise.Promisify = Promise.promisify

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime &lt; threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime &lt; endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime &lt; endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
	Promise.Delay = Promise.delay
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end
Promise.prototype.Timeout = Promise.prototype.timeout

function Promise.prototype:getStatus()
	return self._status
end
Promise.prototype.GetStatus = Promise.prototype.getStatus

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end
Promise.prototype.AndThen = Promise.prototype.andThen
Promise.prototype.Then = Promise.prototype.andThen

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end
Promise.prototype.Catch = Promise.prototype.catch

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end
Promise.prototype.Tap = Promise.prototype.tap

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.AndThenCall = Promise.prototype.andThenCall
Promise.prototype.ThenCall = Promise.prototype.andThenCall

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.AndThenReturn = Promise.prototype.andThenReturn
Promise.prototype.ThenReturn = Promise.prototype.andThenReturn

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end
Promise.prototype.Cancel = Promise.prototype.cancel

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end
Promise.prototype.Finally = Promise.prototype.finally

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end
Promise.prototype.FinallyCall = Promise.prototype.finallyCall

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end
Promise.prototype.FinallyReturn = Promise.prototype.finallyReturn

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end
Promise.prototype.Done = Promise.prototype.done

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end
Promise.prototype.DoneCall = Promise.prototype.doneCall

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end
Promise.prototype.DoneReturn = Promise.prototype.doneReturn

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end
Promise.prototype.AwaitStatus = Promise.prototype.awaitStatus

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end
Promise.prototype.Await = Promise.prototype.await

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end
Promise.prototype.Expect = Promise.prototype.expect

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect
Promise.prototype.AwaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility &lt; v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (&lt; v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end
Promise.prototype.Now = Promise.prototype.now

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end
Promise.prototype.Retry = Promise.prototype.retry

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end
Promise.FromEvent = Promise.fromEvent

return Promise</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">Signal</string>
            <string name="Source">-- Signal
-- Stephen Leitnick
-- Based off of Anaminus' Signal class: https://gist.github.com/Anaminus/afd813efc819bad8e560caea28942010

--[[

	signal = Signal.new()

	signal:Fire(...)
	signal:Wait()
	signal:WaitPromise()
	signal:Destroy()
	signal:DisconnectAll()
	
	connection = signal:Connect(functionHandler)

	connection.Connected
	connection:Disconnect()
	connection:IsConnected()

--]]

local Promise

local Connection = {}
Connection.__index = Connection

function Connection.new(signal, connection)
	local self = setmetatable({
		_signal = signal;
		_conn = connection;
		Connected = true;
	}, Connection)
	return self
end

function Connection:Disconnect()
	if (self._conn) then
		self._conn:Disconnect()
		self._conn = nil
	end
	if (not self._signal) then return end
	self.Connected = false
	local connections = self._signal._connections
	local connectionIndex = table.find(connections, self)
	if (connectionIndex) then
		local n = #connections
		connections[connectionIndex] = connections[n]
		connections[n] = nil
	end
	self._signal = nil
end

function Connection:IsConnected()
	if (self._conn) then
		return self._conn.Connected
	end
	return false
end

Connection.Destroy = Connection.Disconnect

--------------------------------------------

local Signal = {}
Signal.__index = Signal


function Signal.new()
	local self = setmetatable({
		_bindable = Instance.new("BindableEvent");
		_connections = {};
		_args = {};
		_threads = 0;
		_id = 0;
	}, Signal)
	return self
end


function Signal.Is(obj)
	return (type(obj) == "table" and getmetatable(obj) == Signal)
end


function Signal:Fire(...)
	local id = self._id
	self._id = self._id + 1
	self._args[id] = {#self._connections + self._threads, {n = select("#", ...), ...}}
	self._threads = 0
	self._bindable:Fire(id)
end


function Signal:Wait()
	self._threads = self._threads + 1
	local id = self._bindable.Event:Wait()
	local args = self._args[id]
	args[1] = args[1] - 1
	if (args[1] &lt;= 0) then
		self._args[id] = nil
	end
	return table.unpack(args[2], 1, args[2].n)
end


function Signal:WaitPromise()
	return Promise.new(function(resolve)
		resolve(self:Wait())
	end)
end


function Signal:Connect(handler)
	local connection = Connection.new(self, self._bindable.Event:Connect(function(id)
		local args = self._args[id]
		args[1] = args[1] - 1
		if (args[1] &lt;= 0) then
			self._args[id] = nil
		end
		handler(table.unpack(args[2], 1, args[2].n))
	end))
	table.insert(self._connections, connection)
	return connection
end


function Signal:DisconnectAll()
	for _,c in ipairs(self._connections) do
		if (c._conn) then
			c._conn:Disconnect()
		end
	end
	self._connections = {}
	self._args = {}
end


function Signal:Destroy()
	self:DisconnectAll()
	self._bindable:Destroy()
end


function Signal:Init()
	Promise = self.Shared.Promise
end


return Signal</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">StringUtil</string>
            <string name="Source">-- String Util
-- Stephen Leitnick
-- December 3, 2019

--[[

	StringUtil.Trim(String str)
	StringUtil.TrimStart(String str)
	StringUtil.TrimEnd(String str)
	StringUtil.EqualsIgnoreCase(String str, String compare)
	StringUtil.RemoveWhitespace(String str)
	StringUtil.RemoveExcessWhitespace(String str)
	StringUtil.EndsWith(String str, String endsWith)
	StringUtil.StartsWith(String str, String startsWith)
	StringUtil.Contains(String str, String contains)
	StringUtil.ToCharArray(String str)
	StringUtil.ToByteArray(String str)
	StringUtil.ByteArrayToString(Table bytes)
	StringUtil.ToCamelCase(String str)
	StringUtil.ToPascalCase(String str)
	StringUtil.ToSnakeCase(String str [, uppercase])
	StringUtil.ToKebabCase(String str [, uppercase])
	StringUtil.Escape(str)
	StringUtil.StringBuilder()

	EXAMPLES:

		Trim:

			Trims whitespace from the start and end of the string.

			StringUtil.Trim("  hello world  ") == "hello world"


		TrimStart:

			The same as Trim, but only trims the start of the string.

			StringUtil.TrimStart("  hello world  ") == "hello world  "


		TrimEnd:

			The same as Trim, but only trims the end of the string.

			StringUtil.TrimEnd("  hello world  ") == "  hello world"


		EqualsIgnoreCase:

			Checks if two strings are equal, but ignores their case.

			StringUtil.EqualsIgnoreCase("HELLo woRLD", "hEllo wORLd") == true


		RemoveWhitespace:

			Removes all whitespace from a string.

			StringUtil.RemoveWhitespace("  hello World!\n") == "helloWorld!"


		RemoveExcessWhitespace:

			Replaces all whitespace with a single space. This does not trim the string.

			StringUtil.RemoveExcessWhitespace("This     is    a   \n  test") == "This is a test"


		EndsWith:

			Checks if a string ends with a certain string.

			StringUtil.EndsWith("Hello world", "rld") == true


		StartsWith:

			Checks if a string starts with a certain string.

			StringUtil.StartsWith("Hello world", "He") == true


		Contains:

			Checks if a string contains another string.

			StringUtil.Contains("Hello world", "lo wor") == true


		ToCharArray:

			Returns a table of all the characters in the string.

			StringUtil.ToCharArray("Hello") >>> {"H","e","l","l","o"}


		ToByteArray:

			Returns a table of all the bytes of each character in the string.

			StringUtil.ToByteArray("Hello") >>> {72,101,108,108,111}


		ByteArrayToString:

			Transforms an array of bytes into a string.

			StringUtil.ByteArrayToString({97, 98, 99}) == "abc"


		ToCamelCase:
		
			Returns a string in camelCase.

			StringUtil.ToCamelCase("Hello_world-abc") == "helloWorldAbc"


		ToPascalCase:
		
			Returns a string in PascalCase.

			StringUtil.ToPascalCase("Hello_world-abc") == "HelloWorldAbc"


		ToSnakeCase:
		
			Returns a string in snake_case or SNAKE_CASE.

			StringUtil.ToPascalCase("Hello_world-abc") == "hello_world_abc"
			StringUtil.ToPascalCase("Hello_world-abc", true) == "HELLO_WORLD_ABC"


		ToKebabCase:
		
			Returns a string in kebab-case or KEBAB-CASE.

			StringUtil.ToKebabCase("Hello_world-abc") == "hello-world-abc"
			StringUtil.ToKebabCase("Hello_world-abc", true) == "HELLO-WORLD-ABC"


		Escape:

			Escapes a string from pattern characters. In other words, it prefixes
			any special pattern characters with a %. For example, the dollar
			sign $ would become %$. See the example below.

			StringUtil.Escape("Hello. World$ ^-^") == "Hello%. World%$ %^%-%^"


		StringBuilder:

			Creates a StringBuilder object that can be used to build a string. This
			is useful when a large string needs to be concatenated. Traditional
			concatenation of a string using ".." can be a performance issue, and thus
			StringBuilders can be used to store the pieces of the string in a table
			and then concatenate them all at once.

			local builder = StringUtil.StringBuilder()

			builder:Append("world")
			builder:Prepend("Hello ")
			builder:ToString() == "Hello world"
			tostring(builder)  == "Hello world"

--]]


local StringUtil = {}

local MAX_TUPLE = 7997


function StringUtil.Escape(str)
	local escaped = str:gsub("([%.%$%^%(%)%[%]%+%-%*%?%%])", "%%%1")
	return escaped
end


function StringUtil.Trim(str)
	return str:match("^%s*(.-)%s*$")
end


function StringUtil.TrimStart(str)
	return str:match("^%s*(.+)")
end


function StringUtil.TrimEnd(str)
	return str:match("(.-)%s*$")
end


function StringUtil.RemoveExcessWhitespace(str)
	return str:gsub("%s+", " ")
end


function StringUtil.RemoveWhitespace(str)
	return str:gsub("%s+", "")
end


function StringUtil.EndsWith(str, ends)
	return str:match(StringUtil.Escape(ends) .. "$") ~= nil
end


function StringUtil.StartsWith(str, starts)
	return str:match("^" .. StringUtil.Escape(starts)) ~= nil
end


function StringUtil.Contains(str, contains)
	return str:find(contains) ~= nil
end


function StringUtil.StringBuilder()
	local sb = {}
	local str = {}
	function sb:Append(s)
		str[#str + 1] = s
	end
	function sb:Prepend(s)
		table.insert(str, 1, s)
	end
	function sb:ToString()
		return table.concat(str, "")
	end
	setmetatable(sb, {__tostring=sb.ToString})
	return sb
end


function StringUtil.ToCharArray(str)
	local len = #str
	local chars = table.create(len)
	for i = 1,len do
		chars[i] = str:sub(i, i)
	end
	return chars
end


function StringUtil.ToByteArray(str)
	local len = #str
	if (len == 0) then return {} end
	if (len &lt;= MAX_TUPLE) then
		return table.pack(str:byte(1, #str))
	end
	local bytes = table.create(len)
	for i = 1,len do
		bytes[i] = str:sub(i, i):byte()
	end
	return bytes
end


function StringUtil.ByteArrayToString(bytes)
	local size = #bytes
	if (size &lt;= MAX_TUPLE) then
		return string.char(table.unpack(bytes))
	end
	local numChunks = math.ceil(size / MAX_TUPLE)
	local stringBuild = table.create(numChunks)
	for i = 1, numChunks do
		local chunk = string.char(table.unpack(bytes, ((i - 1) * MAX_TUPLE) + 1, math.min(size, ((i - 1) * MAX_TUPLE) + MAX_TUPLE)))
		stringBuild[i] = chunk
	end
	return table.concat(stringBuild, "")
end


function StringUtil.EqualsIgnoreCase(str1, str2)
	return (str1:lower() == str2:lower())
end


function StringUtil.ToCamelCase(str)
	str = str:gsub("[%-_]+([^%-_])", function(s) return s:upper() end)
	return str:sub(1, 1):lower() .. str:sub(2)
end


function StringUtil.ToPascalCase(str)
	str = StringUtil.ToCamelCase(str)
	return str:sub(1, 1):upper() .. str:sub(2)
end


function StringUtil.ToSnakeCase(str, uppercase)
	str = str:gsub("[%-_]+", "_"):gsub("([^%u%-_])(%u)", function(s1, s2) return s1 .. "_" .. s2:lower() end)
	if (uppercase) then str = str:upper() else str = str:lower() end
	return str
end


function StringUtil.ToKebabCase(str, uppercase)
	str = str:gsub("[%-_]+", "-"):gsub("([^%u%-_])(%u)", function(s1, s2) return s1 .. "-" .. s2:lower() end)
	if (uppercase) then str = str:upper() else str = str:lower() end
	return str
end


setmetatable(StringUtil, {__index = string})


return StringUtil</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">TableUtil</string>
            <string name="Source">-- Table Util
-- Stephen Leitnick
-- September 13, 2017

--[[
	
	TableUtil.Copy(Table tbl)
	TableUtil.CopyShallow(Table tbl)
	TableUtil.Sync(Table tbl, Table templateTbl)
	TableUtil.Print(Table tbl, String label, Boolean deepPrint)
	TableUtil.FastRemove(Table tbl, Number index)
	TableUtil.FastRemoveFirstValue(Table tbl, Variant value)
	TableUtil.Map(Table tbl, Function callback)
	TableUtil.Filter(Table tbl, Function callback)
	TableUtil.Reduce(Table tbl, Function callback [, Number initialValue])
	TableUtil.Assign(Table target, ...Table sources)
	TableUtil.IndexOf(Table tbl, Variant item)
	TableUtil.Reverse(Table tbl)
	TableUtil.Shuffle(Table tbl)
	TableUtil.IsEmpty(Table tbl)
	TableUtil.EncodeJSON(Table tbl)
	TableUtil.DecodeJSON(String json)

	EXAMPLES:

		Copy:

			Performs a deep copy of the given table. In other words,
			all nested tables will also get copied.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.Copy(tbl)


		CopyShallow:

			Performs a shallow copy of the given table. In other words,
			all nested tables will not be copied, but only moved by
			reference. Thus, a nested table in both the original and
			the copy will be the same.

			local tbl = {"a", "b", "c"}
			local tblCopy = TableUtil.CopyShallow(tbl)


		Sync:

			Synchronizes a table to a template table. If the table does not have an
			item that exists within the template, it gets added. If the table has
			something that the template does not have, it gets removed.

			local tbl1 = {kills = 0; deaths = 0; points = 0}
			local tbl2 = {points = 0}
			TableUtil.Sync(tbl2, tbl1)  -- In words: "Synchronize table2 to table1"
			print(tbl2.deaths)


		Print:

			Prints out the table to the output in an easy-to-read format. Good for
			debugging tables. If deep printing, avoid cyclical references.

			local tbl = {a = 32; b = 64; c = 128; d = {x = 0; y = 1; z = 2}}
			TableUtil.Print(tbl, "My Table", true)


		FastRemove:

			Removes an item from an array at a given index. Only use this if you do
			NOT care about the order of your array. This works by simply popping the
			last item in the array and overwriting the given index with the last
			item. This is O(1), compared to table.remove's O(n) speed.

			local tbl = {"hello", "there", "this", "is", "a", "test"}
			TableUtil.FastRemove(tbl, 2)   -- Remove "there" in the array
			print(table.concat(tbl, " "))  -- > hello test is a


		FastRemoveFirstValue:

			Calls FastRemove on the first index that holds the given value.

			local tbl = {"abc", "hello", "hi", "goodbye", "hello", "hey"}
			local removed, atIndex = TableUtil.FastRemoveFirstValue(tbl, "hello")
			if (removed) then
				print("Removed at index " .. atIndex)
				print(table.concat(tbl, " "))  -- > abc hi goodbye hello hey
			else
				print("Did not find value")
			end

		
		Map:

			This allows you to construct a new table by calling the given function
			on each item in the table.

			local peopleData = {
				{firstName = "Bob"; lastName = "Smith"};
				{firstName = "John"; lastName = "Doe"};
				{firstName = "Jane"; lastName = "Doe"};
			}

			local people = TableUtil.Map(peopleData, function(item)
				return {Name = item.firstName .. " " .. item.lastName}
			end)

			-- 'people' is now an array that looks like: { {Name = "Bob Smith"}; ... }


		Filter:

			This allows you to create a table based on the given table and a filter
			function. If the function returns 'true', the item remains in the new
			table; if the function returns 'false', the item is discluded from the
			new table.

			local people = {
				{Name = "Bob Smith"; Age = 42};
				{Name = "John Doe"; Age = 34};
				{Name = "Jane Doe"; Age = 37};
			}

			local peopleUnderForty = TableUtil.Filter(people, function(item)
				return item.Age &lt; 40
			end)


		Reduce:

			This allows you to reduce an array to a single value. Useful for quickly
			summing up an array.

			local tbl = {40, 32, 9, 5, 44}
			local tblSum = TableUtil.Reduce(tbl, function(accumulator, value)
				return accumulator + value
			end)
			print(tblSum)  -- > 130


		Assign:

			This allows you to assign values from multiple tables into one. The
			Assign function is very similar to JavaScript's Object.Assign() and
			is useful for things such as composition-designed systems.

			local function Driver()
				return {
					Drive = function(self) self.Speed = 10 end;
				}
			end

			local function Teleporter()
				return {
					Teleport = function(self, pos) self.Position = pos end;
				}
			end

			local function CreateCar()
				local state = {
					Speed = 0;
					Position = Vector3.new();
				}
				-- Assign the Driver and Teleporter components to the car:
				return TableUtil.Assign({}, Driver(), Teleporter())
			end

			local car = CreateCar()
			car:Drive()
			car:Teleport(Vector3.new(0, 10, 0))


		IndexOf:

			Returns the index of the given item in the table. If not found, this
			will return nil.

			This is the same as table.find, which Roblox added after this method
			was written. To keep backwards compatibility, this method will continue
			to exist, but will point directly to table.find.

			local tbl = {"Hello", 32, true, "abc"}
			local abcIndex = TableUtil.IndexOf(tbl, "abc")     -- > 4
			local helloIndex = TableUtil.IndexOf(tbl, "Hello") -- > 1
			local numberIndex = TableUtil.IndexOf(tbl, 64)     -- > nil


		Reverse:

			Creates a reversed version of the array. Note: This is a shallow
			copy, so existing references will remain within the new table.

			local tbl = {2, 4, 6, 8}
			local rblReversed = TableUtil.Reverse(tbl)  -- > {8, 6, 4, 2}


		Shuffle:

			Shuffles (i.e. randomizes) an array. This uses the Fisher-Yates algorithm.

			local tbl = {1, 2, 3, 4, 5, 6, 7, 8, 9}
			TableUtil.Shuffle(tbl)
			print(table.concat(tbl, ", "))  -- e.g. > 3, 6, 9, 2, 8, 4, 1, 7, 5
	
--]]



local TableUtil = {}

local http = game:GetService("HttpService")

local IndexOf = table.find


local function CopyTable(t)
	assert(type(t) == "table", "First argument must be a table")
	local tCopy = table.create(#t)
	for k,v in pairs(t) do
		if (type(v) == "table") then
			tCopy[k] = CopyTable(v)
		else
			tCopy[k] = v
		end
	end
	return tCopy
end


local function CopyTableShallow(t)
	local tCopy = table.create(#t)
	for k,v in pairs(t) do tCopy[k] = v end
	return tCopy
end


local function Sync(tbl, templateTbl)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(type(templateTbl) == "table", "Second argument must be a table")
	
	-- If 'tbl' has something 'templateTbl' doesn't, then remove it from 'tbl'
	-- If 'tbl' has something of a different type than 'templateTbl', copy from 'templateTbl'
	-- If 'templateTbl' has something 'tbl' doesn't, then add it to 'tbl'
	for k,v in pairs(tbl) do
		
		local vTemplate = templateTbl[k]
		
		-- Remove keys not within template:
		if (vTemplate == nil) then
			tbl[k] = nil
			
		-- Synchronize data types:
		elseif (type(v) ~= type(vTemplate)) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		
		-- Synchronize sub-tables:
		elseif (type(v) == "table") then
			Sync(v, vTemplate)
		end
		
	end
	
	-- Add any missing keys:
	for k,vTemplate in pairs(templateTbl) do
		
		local v = tbl[k]
		
		if (v == nil) then
			if (type(vTemplate) == "table") then
				tbl[k] = CopyTable(vTemplate)
			else
				tbl[k] = vTemplate
			end
		end
		
	end
	
end


local function FastRemove(t, i)
	local n = #t
	t[i] = t[n]
	t[n] = nil
end


local function Map(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = table.create(#t)
	for k,v in pairs(t) do
		newT[k] = f(v, k, t)
	end
	return newT
end


local function Filter(t, f)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	local newT = table.create(#t)
	if (#t > 0) then
		local n = 0
		for i = 1,#t do
			local v = t[i]
			if (f(v, i, t)) then
				n = (n + 1)
				newT[n] = v
			end
		end
	else
		for k,v in pairs(t) do
			if (f(v, k, t)) then
				newT[k] = v
			end
		end
	end
	return newT
end


local function Reduce(t, f, init)
	assert(type(t) == "table", "First argument must be a table")
	assert(type(f) == "function", "Second argument must be an array")
	assert(init == nil or type(init) == "number", "Third argument must be a number or nil")
	local result = (init or 0)
	for k,v in pairs(t) do
		result = f(result, v, k, t)
	end
	return result
end


-- tableUtil.Assign(Table target, ...Table sources)
local function Assign(target, ...)
	for _,src in ipairs({...}) do
		for k,v in pairs(src) do
			target[k] = v
		end
	end
	return target
end


local function Print(tbl, label, deepPrint)

	assert(type(tbl) == "table", "First argument must be a table")
	assert(label == nil or type(label) == "string", "Second argument must be a string or nil")
	
	label = (label or "TABLE")
	
	local strTbl = {}
	local indent = " - "
	
	-- Insert(string, indentLevel)
	local function Insert(s, l)
		strTbl[#strTbl + 1] = (indent:rep(l) .. s .. "\n")
	end
	
	local function AlphaKeySort(a, b)
		return (tostring(a.k) &lt; tostring(b.k))
	end
	
	local function PrintTable(t, lvl, lbl)
		Insert(lbl .. ":", lvl - 1)
		local nonTbls = {}
		local tbls = {}
		local keySpaces = 0
		for k,v in pairs(t) do
			if (type(v) == "table") then
				table.insert(tbls, {k = k, v = v})
			else
				table.insert(nonTbls, {k = k, v = "[" .. typeof(v) .. "] " .. tostring(v)})
			end
			local spaces = #tostring(k) + 1
			if (spaces > keySpaces) then
				keySpaces = spaces
			end
		end
		table.sort(nonTbls, AlphaKeySort)
		table.sort(tbls, AlphaKeySort)
		for _,v in ipairs(nonTbls) do
			Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. v.v, lvl)
		end
		if (deepPrint) then
			for _,v in ipairs(tbls) do
				PrintTable(v.v, lvl + 1, tostring(v.k) .. (" "):rep(keySpaces - #tostring(v.k)) .. " [Table]")
			end
		else
			for _,v in ipairs(tbls) do
				Insert(tostring(v.k) .. ":" .. (" "):rep(keySpaces - #tostring(v.k)) .. "[Table]", lvl)
			end
		end
	end
	
	PrintTable(tbl, 1, label)
	
	print(table.concat(strTbl, ""))
	
end


local function Reverse(tbl)
	local n = #tbl
	local tblRev = table.create(n)
	for i = 1,n do
		tblRev[i] = tbl[n - i + 1]
	end
	return tblRev
end


local function Shuffle(tbl)
	assert(type(tbl) == "table", "First argument must be a table")
	local rng = Random.new()
	for i = #tbl, 2, -1 do
		local j = rng:NextInteger(1, i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
end


local function IsEmpty(tbl)
	return (next(tbl) == nil)
end


local function EncodeJSON(tbl)
	return http:JSONEncode(tbl)
end


local function DecodeJSON(str)
	return http:JSONDecode(str)
end


local function FastRemoveFirstValue(t, v)
	local index = IndexOf(t, v)
	if (index) then
		FastRemove(t, index)
		return true, index
	end
	return false, nil
end


TableUtil.Copy = CopyTable
TableUtil.CopyShallow = CopyTableShallow
TableUtil.Sync = Sync
TableUtil.FastRemove = FastRemove
TableUtil.FastRemoveFirstValue = FastRemoveFirstValue
TableUtil.Print = Print
TableUtil.Map = Map
TableUtil.Filter = Filter
TableUtil.Reduce = Reduce
TableUtil.Assign = Assign
TableUtil.IndexOf = IndexOf
TableUtil.Reverse = Reverse
TableUtil.Shuffle = Shuffle
TableUtil.IsEmpty = IsEmpty
TableUtil.EncodeJSON = EncodeJSON
TableUtil.DecodeJSON = DecodeJSON


return TableUtil</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">Thread</string>
            <string name="Source">-- Thread
-- Stephen Leitnick
-- January 5, 2020

--[[

	Thread.SpawnNow(func, ...)
	Thread.Spawn(func, ...)
	Thread.Delay(waitTime, func, ...)

	SpawnNow(Function func, Arguments...)

		>	Uses a BindableEvent to spawn a new thread
			immediately. More performance-intensive than
			using Thread.Spawn, but will guarantee a
			thread is started immediately.

		>	Use this only if the thread must be executed
			right away, otherwise use Thread.Spawn for
			the sake of performance.

	Spawn(Function func, Arguments...)

		>	Uses RunService's Heartbeat to spawn a new
			thread on the next heartbeat and then
			call the given function.

		>	Better performance than Thread.SpawnNow, but
			will have a short delay of 1 frame before
			calling the function.

	Delay(Number waitTime, Function func, Arguments...)

		>	The same as Thread.Spawn, but waits to call
			the function until the in-game time as elapsed
			by 'waitTime' amount.

		>	Returns the connection to the Heartbeat event,
			so the delay can be cancelled by disconnecting
			the returned connection.

	DelayRepeat(Number intervalTime, Function func, Arguments...)

		>	The same as Thread.Delay, except it repeats
			indefinitely.
		
		>	Returns the Heartbeat connection, thus the
			repeated delay can be stopped by disconnecting
			the returned connection.

		>	Properly bound to the time interval, thus will
			not experience drift.

	
	Examples:

		Thread.Spawn(function()
			print("Hello from Spawn")
		end)

		Thread.Delay(1, function()
			print("Hello from Delay")
		end)

		Thread.SpawnNow(function()
			print("Hello from SpawnNow")
		end)

		local delayConnection = Thread.Delay(5, function()
			print("Hello?")
		end)
		delayConnection:Disconnect()

		local repeatConnection = Thread.DelayRepeat(1, function()
			print("Hello again", tick())
		end)
		wait(5)
		repeatConnection:Disconnect()


	Why:
		
		The built-in 'spawn' and 'delay' functions have the
		potential to be throttled unknowingly. This can cause
		all sorts of problems. Developers need to be certain
		when their code is going to run. This small library
		helps give the same functionality as 'spawn' and 'delay'
		but with the expected behavior.

	Why not coroutines:
		
		Coroutines are powerful, but can be extremely difficult
		to debug due to the ways that coroutines obscure the
		stack trace.

	Credit:
	
		evaera &amp; buildthomas: https://devforum.roblox.com/t/coroutines-v-s-spawn-which-one-should-i-use/368966
		Quenty: FastSpawn (AKA SpawnNow) method using BindableEvent

--]]



local Thread = {}

local heartbeat = game:GetService("RunService").Heartbeat


function Thread.SpawnNow(func, ...)
	--[[
		This method was originally written by Quenty and is slightly
		modified for this module. The original source can be found in
		the link below, as well as the MIT license:
			https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Utility/fastSpawn.lua
			https://github.com/Quenty/NevermoreEngine/blob/version2/LICENSE.md
	--]]
	local args = table.pack(...)
	local bindable = Instance.new("BindableEvent")
	bindable.Event:Connect(function() func(table.unpack(args, 1, args.n)) end)
	bindable:Fire()
	bindable:Destroy()
end


function Thread.Spawn(func, ...)
	local args = table.pack(...)
	local hb
	hb = heartbeat:Connect(function()
		hb:Disconnect()
		func(table.unpack(args, 1, args.n))
	end)
end


function Thread.Delay(waitTime, func, ...)
	local args = table.pack(...)
	local executeTime = (tick() + waitTime)
	local hb
	hb = heartbeat:Connect(function()
		if (tick() >= executeTime) then
			hb:Disconnect()
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


function Thread.DelayRepeat(intervalTime, func, ...)
	local args = table.pack(...)
	local nextExecuteTime = (tick() + intervalTime)
	local hb
	hb = heartbeat:Connect(function()
		if (tick() >= nextExecuteTime) then
			nextExecuteTime = (tick() + intervalTime)
			func(table.unpack(args, 1, args.n))
		end
	end)
	return hb
end


return Thread</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">VectorUtil</string>
            <string name="Source">-- Vector Util
-- Stephen Leitnick
-- April 22, 2020

--[[

	VectorUtil.ClampMagnitude(vector, maxMagnitude)
	VectorUtil.AngleBetween(vector1, vector2)
	VectorUtil.AngleBetweenSigned(vector1, vector2, axisVector)


	EXAMPLES:

		ClampMagnitude:

			Clamps the magnitude of a vector so it is only a certain length.

			ClampMagnitude(Vector3.new(100, 0, 0), 15) == Vector3.new(15, 0, 0)
			ClampMagnitude(Vector3.new(10, 0, 0), 20)  == Vector3.new(10, 0, 0)

		
		AngleBetween:

			Finds the angle (in radians) between two vectors.

			v1 = Vector3.new(10, 0, 0)
			v2 = Vector3.new(0, 10, 0)
			AngleBetween(v1, v2) == math.rad(90)

		
		AngleBetweenSigned:

			Same as AngleBetween, but returns a signed value.

			v1 = Vector3.new(10, 0, 0)
			v2 = Vector3.new(0, 0, -10)
			axis = Vector3.new(0, 1, 0)
			AngleBetweenSigned(v1, v2, axis) == math.rad(90)

--]]


local VectorUtil = {}


function VectorUtil.ClampMagnitude(vector, maxMagnitude)
	return (vector.Magnitude > maxMagnitude and (vector.Unit * maxMagnitude) or vector)
end


function VectorUtil.AngleBetween(vector1, vector2)
	return math.acos(math.clamp(vector1.Unit:Dot(vector2.Unit), -1, 1))
end


function VectorUtil.AngleBetweenSigned(vector1, vector2, axisVector)
	local angle = VectorUtil.AngleBetween(vector1, vector2)
	return angle * math.sign(axisVector:Dot(vector1:Cross(vector2)))
end


return VectorUtil</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="19">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="20">
      <Properties>
        <string name="Name">Aero</string>
      </Properties>
      <Item class="Folder" referent="21">
        <Properties>
          <string name="Name">Internal</string>
        </Properties>
        <Item class="Script" referent="22">
          <Properties>
            <string name="Name">AeroServer</string>
            <string name="Source"><![CDATA[-- Aero Server
-- Stephen Leitnick
-- July 21, 2017



local AeroServer = {
	Services = {};
	Modules = {};
	Shared = {};
}

local mt = {__index = AeroServer}

local servicesFolder = game:GetService("ServerStorage").Aero.Services
local modulesFolder = game:GetService("ServerStorage").Aero.Modules
local sharedFolder = game:GetService("ReplicatedStorage").Aero.Shared
local internalFolder = game:GetService("ReplicatedStorage").Aero.Internal

local remoteServices = Instance.new("Folder")
remoteServices.Name = "AeroRemoteServices"

local players = {}
local modulesAwaitingStart = {}

local SpawnNow = require(sharedFolder.Thread:Clone()).SpawnNow
local Settings = require(internalFolder:WaitForChild("Settings"))

local settingsPerTbl = {}


local function PreventEventRegister()
	error("Cannot register event after Init method")
end

local function PreventFunctionRegister()
	error("Cannot register function after Init method")
end

local function PreventMethodCache()
	error("Cannot mark method as cachable after Init method")
end


function AeroServer:RegisterEvent(eventName)
	local event = self.Shared.Signal.new()
	self._events[eventName] = event
	return event
end


function AeroServer:RegisterClientEvent(eventName)
	local event = Instance.new("RemoteEvent")
	event.Name = eventName
	event.Parent = self._remoteFolder
	self._clientEvents[eventName] = event
	return event
end


function AeroServer:Fire(eventName, ...)
	self._events[eventName]:Fire(...)
end


function AeroServer:FireEvent(eventName, ...)
	warn("FireEvent has been deprecated in favor of Fire")
	self:Fire(eventName, ...)
end


function AeroServer:FireClient(eventName, client, ...)
	self._clientEvents[eventName]:FireClient(client, ...)
end


function AeroServer:FireClientEvent(eventName, client, ...)
	warn("FireClientEvent has been deprecated in favor of FireClient")
	self:FireClient(eventName, client, ...)
end


function AeroServer:FireAllClients(eventName, ...)
	self._clientEvents[eventName]:FireAllClients(...)
end


function AeroServer:FireAllClientsEvent(eventName, ...)
	warn("FireAllClientsEvent has been deprecated in favor of FireAllClients")
	self:FireAllClients(eventName, ...)
end


function AeroServer:FireOtherClients(eventName, clientIgnore, ...)
	local event = self._clientEvents[eventName]
	for _,player in ipairs(players) do
		if (player ~= clientIgnore) then
			event:FireClient(player, ...)
		end
	end
end


function AeroServer:FireAllClientsEventExcept(eventName, client, ...)
	warn("FireAllClientsEventExcept has been deprecated in favor of FireOtherClients")
	self:FireOtherClients(eventName, client, ...)
end


function AeroServer:ConnectEvent(eventName, func)
	return self._events[eventName]:Connect(func)
end


function AeroServer:ConnectClientEvent(eventName, func)
	return self._clientEvents[eventName].OnServerEvent:Connect(func)
end


function AeroServer:WaitForEvent(eventName)
	return self._events[eventName]:Wait()
end


function AeroServer:WaitForClientEvent(eventName)
	return self._clientEvents[eventName]:Wait()
end


function AeroServer:RegisterClientFunction(funcName, func, cacheTTL)
	local remoteFunc = Instance.new("RemoteFunction")
	remoteFunc.Name = funcName
	remoteFunc.OnServerInvoke = function(...)
		return func(self.Client, ...)
	end
	if (cacheTTL ~= nil) then
		local cache = Instance.new("NumberValue")
		cache.Name = "Cache"
		cache.Value = cacheTTL
		cache.Parent = remoteFunc
	end
	remoteFunc.Parent = self._remoteFolder
	return remoteFunc
end


function AeroServer:WrapModule(tbl)
	assert(type(tbl) == "table", "Expected table for argument")
	tbl._events = {}
	setmetatable(tbl, mt)
	local objSettings = (settingsPerTbl[tbl] or Settings:GetDefault())
	if (type(tbl.Init) == "function" and not (objSettings.PreventInit or tbl.__aeroPreventInit)) then
		tbl:Init()
	end
	if (type(tbl.Start) == "function" and not (objSettings.PreventStart or tbl.__aeroPreventStart)) then
		if (modulesAwaitingStart) then
			modulesAwaitingStart[#modulesAwaitingStart + 1] = tbl
		else
			SpawnNow(tbl.Start, tbl)
		end
	end
	return tbl
end


function AeroServer:CacheClientMethod(methodName, ttl)
	assert(self._clientCaches, "CacheClientMethod must be called within Init method")
	assert(type(methodName) == "string", "CacheClientMethod argument #1 must be a string")
	assert(self.Client and type(self.Client[methodName]) == "function", "CacheClientMethod argument #1 must be a client method")
	if (ttl == nil) then ttl = 0 end
	assert(type(ttl) == "number" and ttl >= 0, "CacheClientMethod argument #2 must be a number >= 0")
	self._clientCaches[methodName] = (ttl or 0)
end


-- Setup table to load modules on demand:
local function LazyLoadSetup(tbl, folder)
	setmetatable(tbl, {
		__index = function(t, i)
			local child = folder[i]
			if (child:IsA("ModuleScript")) then
				local objSettings = Settings:Get(child)
				local obj = require(child)
				settingsPerTbl[obj] = objSettings
				rawset(t, i, obj)
				if (type(obj) == "table" and not objSettings.Standalone) then
					-- Only wrap module if it's actually a table, and not a table disguised as a function:
					local objMetatable = getmetatable(obj)
					if (not (objMetatable and objMetatable.__call)) then
						AeroServer:WrapModule(obj)
					end
				end
				return obj
			elseif (child:IsA("Folder")) then
				local nestedTbl = {}
				rawset(t, i, nestedTbl)
				LazyLoadSetup(nestedTbl, child)
				return nestedTbl
			end
		end;
	})
end


-- Load service from module:
local function LoadService(module, servicesTbl, parentFolder)

	local serviceSettings = Settings:Get(module)
	
	local remoteFolder = Instance.new("Folder")
	remoteFolder.Name = module.Name
	remoteFolder.Parent = parentFolder
	
	local service = require(module)
	servicesTbl[module.Name] = service
	
	if (type(service.Client) ~= "table") then
		service.Client = {}
	end
	service.Client.Server = service
	
	setmetatable(service, mt)
	
	service._events = {}
	service._clientEvents = {}
	service._clientCaches = {}
	service._remoteFolder = remoteFolder

	settingsPerTbl[service] = serviceSettings
	
end


local function InitService(service)
	
	-- Initialize:
	if (type(service.Init) == "function") then
		service:Init()
	end
	
	-- Client functions:
	for funcName,func in pairs(service.Client) do
		if (type(func) == "function") then
			service:RegisterClientFunction(funcName, func, service._clientCaches[funcName])
		end
	end

	-- Disallow registering events/functions after init:
	service.RegisterEvent = PreventEventRegister
	service.RegisterClientEvent = PreventEventRegister
	service.RegisterClientFunction = PreventFunctionRegister
	service.CacheClientMethod = PreventMethodCache
	
end


local function StartService(service)

	-- Start services on separate threads:
	if (type(service.Start) == "function") then
		SpawnNow(service.Start, service)
	end

end


local function Init()

	local function PlayerAdded(player)
		players[#players + 1] = player
	end

	local function PlayerRemoving(player)
		local nPlayers = #players
		for i = 1,nPlayers do
			if (players[i] == player) then
				players[i] = players[nPlayers]
				players[nPlayers] = nil
			end
		end
	end
	
	-- Load service modules:
	local function LoadAllServices(parent, servicesTbl, parentFolder)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("ModuleScript")) then
				if (not Settings:IsSettingsModule(child)) then
					LoadService(child, servicesTbl, parentFolder)
				end
			elseif (child:IsA("Folder")) then
				local tbl = {}
				local folder = Instance.new("Folder")
				folder.Name = child.Name
				folder.Parent = parentFolder
				servicesTbl[child.Name] = tbl
				LoadAllServices(child, tbl, folder)
			end
		end
	end
	
	-- Initialize services:
	local function InitAllServices(services)
		-- Collect all services:
		local serviceTables = {}
		local function CollectServices(svcs)
			for _,service in pairs(svcs) do
				if (getmetatable(service) == mt) then
					serviceTables[#serviceTables + 1] = service
				else
					CollectServices(service)
				end
			end
		end
		CollectServices(services)
		-- Sort services by optional Order setting or __aeroOrder field:
		local function GetOrder(service)
			local svcSettings = settingsPerTbl[service]
			local order
			if (type(svcSettings.Order) == "number") then
				order = svcSettings.Order
			elseif (type(service.__aeroOrder) == "number") then
				order = service.__aeroOrder
			else
				order = Settings.InternalSettings.DefaultOrder
			end
			return order
		end
		table.sort(serviceTables, function(a, b)
			return (GetOrder(a) < GetOrder(b))
		end)
		-- Initialize services:
		for _,service in ipairs(serviceTables) do
			InitService(service)
		end
	end

	-- Remove unused folders:
	local function ScanRemoteFoldersForEmpty(parent)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("Folder")) then
				local remoteFunction = child:FindFirstChildWhichIsA("RemoteFunction", true)
				local remoteEvent = child:FindFirstChildWhichIsA("RemoteEvent", true)
				if ((not remoteFunction) and (not remoteEvent)) then
					child:Destroy()
				else
					ScanRemoteFoldersForEmpty(child)
				end
			end
		end
	end
	
	-- Start services:
	local function StartAllServices(services)
		for _,service in pairs(services) do
			if (getmetatable(service) == mt) then
				StartService(service)
			else
				StartAllServices(service)
			end
		end
	end

	-- Start modules that were already loaded:
	local function StartLoadedModules()
		for _,tbl in pairs(modulesAwaitingStart) do
			SpawnNow(tbl.Start, tbl)
		end
		modulesAwaitingStart = nil
	end

	--------------------------------------------------------------------

	players = game:GetService("Players"):GetPlayers()
	game:GetService("Players").PlayerAdded:Connect(PlayerAdded)
	game:GetService("Players").PlayerRemoving:Connect(PlayerRemoving)
	
	-- Lazy-load server and shared modules:
	LazyLoadSetup(AeroServer.Modules, modulesFolder)
	LazyLoadSetup(AeroServer.Shared, sharedFolder)

	-- Load, init, and start services:
	LoadAllServices(servicesFolder, AeroServer.Services, remoteServices)
	InitAllServices(AeroServer.Services)
	ScanRemoteFoldersForEmpty(remoteServices)
	StartAllServices(AeroServer.Services)
	StartLoadedModules()
	
	-- Expose server framework to client and global scope:
	remoteServices.Parent = game:GetService("ReplicatedStorage").Aero
	_G.AeroServer = AeroServer
	_G.Aero = AeroServer
	
end


Init()
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="23">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Folder" referent="24">
      <Properties>
        <string name="Name">Aero</string>
      </Properties>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">Modules</string>
        </Properties>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">Data</string>
            <string name="Source">-- Data
-- Stephen Leitnick
-- November 20, 2018


--[[
	
	CONSTRUCTORS:
		data = Data.new(name, scope [, ordered])              [Creates or gets existing Data object for given name and scope]
		data = Data.ForPlayer(userId | player [, ordered])    [Creates or gets existing Data object for given player OR UserId]
		data = Data.ForServer([ordered])                      [Creates or gets existing Data object for the server]

	STATIC FIELDS:
		Data.IsUsingMockService        [Whether or not the MockDataStoreService is being utilized]
		Data.AutoSaveInterval          [How often all data auto-saves. Defaults to '60' seconds]
		Data.PlayerLeftSaveInterval    [How long to wait after a player leaves before saving all data. Defaults to '10' seconds]
		Data.SaveInStudio              [Defaults to 'false'; indicates if data should save when testing in Studio]

	STATIC METHODS:
		Data:OnClose(onCloseFunc)      [Guaranteed to be executed before all data is saved when server is closing]

	FIELDS:
		data.CanAutoSave        [Defaults to 'true']
		data.DestroyOnLeave     [Defaults to 'true'; if linked to a player, 'Destroy()' will automatically be invoked when the player leaves; see static field PlayerLeftSaveInterval]

	METHODS:
		Promise&lt;Value>          data:Get(String key [, Any defaultValue])
		Promise&lt;DataStorePage>  data:GetSorted(Boolean isAscendint, Int pageSize, Number minValue, Number maxValue)
		Promise&lt;Void>           data:Set(String key, String value)
		Promise&lt;Void>           data:Delete(String key)
		Promise&lt;Value>          data:Increment(String key, Number incrementValue)
		Promise&lt;Connection>     data:OnUpdate(String key, Function callback)
		Promise&lt;Void>           data:Save(String key)
		Promise&lt;Void>           data:SaveAll()
		Promise&lt;Void>           data:Destroy([Boolean saveAll])
		Number                  data:GetRequestBudget(DataStoreRequestType requestType)
		Void                    data:MarkDirty(String key)
		
	EVENTS:
		data.Success         data.Success:Connect(String method, String key)
		data.Failed          data.Failed:Connect(String method, String key, String err)

	METHOD DESCRIPTIONS:
		Get
			Gets/loads the value from the key. The optional 'defaultValue' can be used
			if the retrieved value from the DataStore is nil. This method will only
			call the DataStore if it has not yet done so and gotten a non-nil value. If
			a call has already been made for the given key, the value will be cached
			and the cached value will be returned.

		GetSorted
			Calls the GetSortedAsync method on the OrderedDataStore connected to this
			data object. It will return a custom DataStorePage object described below:

			DataStorePage:
				Boolean         dataStorePage.IsFinished
				Promise&lt;Void>   dataStorePage:AdvanceToNextPage()
				Promise&lt;Table>  dataStorePage:GetCurrentPage()

		Set
			Sets the value to the given key in the local cache. This does NOT set the
			value in the DataStore. Call 'Save' or 'SaveAll' to explicitly save to the
			DataStore. Otherwise, the key will automatically save during the auto-save
			period, when the player leaves, or when the server shuts down.

			If you try to set a value to a key that has not yet been cached, it will
			first try to call the DataStore to ensure it is working. If DataStores
			are down, this call will fail, ensuring that you don't start overriding
			values during DataStore downtime.

		Delete
			This deletes the value from the cache AND the DataStore. This is the same
			as calling 'data:Set("key", nil)' but is preferred for its explicit naming.

		Increment
			This increments a value on a given key. If the current value doesn't exist,
			then it will assume a starting value of 0. This will fail if the increment
			or the existing value is not a number.

		OnUpdate
			This registers a function to listen for changes on a key at the DataStore
			level, NOT the cache level. Thus, using 'data:Set()' won't trigger a bound
			function on OnUpdate. In other words, this function can be used to tell
			when a key has been saved onto the DataStore.

		Save
			Saves a cached key to the DataStore. The key must currently have a cached
			value, otherwise this request will fail.

		SaveAll
			Saves all currently cached keys to the DataStore.

		Destroy
			Destroys the data object instance. If 'saveAll' is set to 'true', this will
			also call 'SaveAll' before removing any of the data.

		GetRequestBudget
			This is exactly the same as the DataStoreService's GetRequestBudget. Read
			the documentation on the Roblox Developer site:
			https://developer.roblox.com/api-reference/function/DataStoreService/GetRequestBudgetForRequestType

		MarkDirty
			Marks the key as dirty, which means that it will be forced to save the
			next time a save invocation occurs. This is necessary when making changes
			to tables.
	

	EXAMPLES:

		data = Data.ForPlayer(somePlayer)

		-- Using 'Await' to get money:
		local success, money = data:Get("money", 0):Await()
		if (success) then
			print("Money", money)
		else
			warn("Failed to get money", money)
		end

		-- Using 'Then' to get money:
		data:Get("money", 0):Then(function(money)
			print("Money", money)
		end, function(err)
			warn("Failed to get money", err)
		end)

		-- Setting money:
		data:Set("money", 25):Await()

		-- Saving:
		data:Save("money"):Then(function()
			print("Successfully saved money")
		end):Catch(function(err)
			warn("Failed to save money", err)
		end):Finally(function()
			-- Cleanup stuff
		end)


		-- OrderedDataStore example:
		data = Data.ForPlayer(somePlayer, true)

		data:GetSorted(true, 10, 0, 1000):Then(function(pages)
			return pages:GetCurrentPage()
		end):Then(function(page)
			for k,v in pairs(page) do
				print(k, v)
			end
		end)



	For in-depth info on DataStores:

		https://devforum.roblox.com/t/details-on-datastoreservice-for-advanced-developers/175804

--]]



local Data = {}
Data.__index = Data
Data._onCloseHandlers = {}

-- Static fields; customize as needed:
Data.AutoSaveInterval = 60
Data.PlayerLeftSaveInterval = 10
Data.SaveInStudio = false
Data.Log = false

-- Constants based on internal Roblox DataStore; DO NOT CHANGE:
local NAME_MAX_LEN = 50
local SCOPE_MAX_LEN = 50
local KEY_MAX_LEN = 49

local KEY_MAX_LEN_ERR = "Key must be a string less or equal to " .. KEY_MAX_LEN .. " characters"
local PLAYER_DATA_NAME = "PlayerData"

local dataStoreService = game:GetService("DataStoreService")
Data.IsUsingMockService = false

local dataPool = {}
local assert = assert
local tableUtil
local Promise


local function Log(...)
	if (not Data.Log) then return end
	print("Data ->", ...)
end


local function HeartbeatSpawn(callback, ...)
	local hb
	local args = table.pack(...)
	hb = game:GetService("RunService").Heartbeat:Connect(function()
		hb:Disconnect()
		callback(table.unpack(args, 1, args.n))
	end)
end


-- Check if key matches DataStore criteria:
local function CheckKey(key)
	return (type(key) == "string" and #key &lt;= KEY_MAX_LEN)
end

-- Retrieve cached DataStore from name and scope:
local function GetDataFromNameAndScope(name, scope)
	local ds = dataStoreService:GetDataStore(name, scope)
	return dataPool[ds]
end


---------------------------------------------------------------------------------------------------------------------------
-- DataStorePages wrapper for promises:

local DataStorePages = {}
DataStorePages.__index = DataStorePages
function DataStorePages.new(dsp)
	return setmetatable({
		DSP = dsp;
		IsFinished = dsp.IsFinished;
	}, DataStorePages)
end

function DataStorePages:AdvanceToNextPage()
	return Promise.new(function(resolve, reject)
		local success, err = pcall(self.DSP.AdvanceToNextPageAsync, self.DSP)
		self.IsFinished = self.DSP.IsFinished
		if (success) then resolve() else reject(err) end
	end)
end

function DataStorePages:GetCurrentPage()
	return Promise.new(function(resolve, reject)
		local success, page = pcall(self.DSP.GetCurrentPage, self.DSP)
		if (success) then resolve(page) else reject(page) end
	end)
end
---------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
-- CONSTRUCTORS:


function Data.new(name, scope, ordered)

	-- Check arguments:
	assert(type(name) == "string", "Argument #1 (name) must be a string")
	assert(type(scope) == "string", "Argument #2 (scope) must be a string")
	assert(#name &lt;= NAME_MAX_LEN, "Argument #1 (name) must be less or equal to " .. NAME_MAX_LEN .. " characters")
	assert(#scope &lt;= SCOPE_MAX_LEN, "Argument #1 (scope) must be less or equal to " .. SCOPE_MAX_LEN .. " characters")
	assert(type(ordered) == "boolean" or ordered == nil, "Argument #3 (ordered) must be a boolean or nil")

	ordered = (not not ordered)

	-- Get cached 'data' object if available:
	local ds = (ordered and dataStoreService:GetOrderedDataStore(name, scope) or dataStoreService:GetDataStore(name, scope))
	local self = dataPool[ds]
	if (self and not self._destroyed) then return self end

	-- Create new 'data' object:
	self = setmetatable({
		Name = name;
		Scope = scope;
		CanAutoSave = true;
		DestroyOnLeave = true;
		_ds = ds;
		_cache = {};
		_dirty = {};
		_ordered = ordered;
		_destroyed = false;
		_destroying = false;
	}, Data)
	
	-- Data events:
	self.Success = self.Shared.Signal.new()
	self.Failed = self.Shared.Signal.new()

	dataPool[ds] = self

	Log("Created new Data object:", tostring(self))

	return self

end


function Data.ForPlayer(userId, ordered)
	if (typeof(userId) == "Instance") then
		-- Capture UserId from the player object:
		assert(userId:IsA("Player"), "Expected Player; got " .. userId.ClassName)
		userId = userId.UserId
	else
		assert(type(userId) == "number" and userId >= 0 and math.floor(userId) == userId, "Expected integer >= 0")
	end
	local scope = tostring(userId)
	local data = Data.new(PLAYER_DATA_NAME, scope, ordered)
	return data
end


function Data.ForServer(ordered)
	return Data.new("global", "global", ordered)
end


---------------------------------------------------------------------------------------------------------------------------
-- PRIVATE METHODS:


-- Load a given key from the DataStore:
function Data:_load(key)
	Log("Loading " .. key .. "...")
	return Promise.new(function(resolve, reject)
		-- Call GetAsync and cache the results:
		local success, value = pcall(self._ds.GetAsync, self._ds, key)
		if (success) then
			Log("Succesfully loaded key " .. key .. ":", value)
			self._cache[key] = value
			self._dirty[key] = false
			self.Success:Fire("GetAsync", key)
			resolve(value)
		else
			Log("Failede to load key " .. key)
			self.Failed:Fire("GetAsync", key, value)
			reject(value)
		end
	end)
end


-- Get the cached value from the key, or load it from the DataStore if not yet cached:
function Data:_loadIfNotCached(key)
	if (self:_cacheExists(key)) then
		return Promise.Resolve(self:_getCache(key))
	end
	return self:_load(key)
end


-- Save the key/value to the DataStore:
function Data:_save(key, value)
	Log("Saving " .. key .. "...")
	if (self._dirty[key] == false) then
		-- If not dirty, the given key does not need to be saved:
		Log("No save necessary; " .. key .. " not marked as dirty")
		return Promise.Resolve()
	end
	return Promise.new(function(resolve, reject)
		-- Call SetAsync and mark key as no longer dirty:
		local valBeforeSave = self:_getCache(key)
		local success, err = pcall(self._ds.SetAsync, self._ds, key, value)
		if (success) then
			if (self:_getCache(key) == valBeforeSave) then
				self._dirty[key] = false
			end
			self.Success:Fire("SetAsync", key)
			Log("Successfully saved " .. key .. ":", value)
			resolve()
		else
			Log("Failed to save " .. key)
			self.Failed:Fire("SetAsync", key, err)
			reject(err)
		end
	end)
end


function Data:_delete(key)
	Log("Deleting " .. key .. "...")
	return Promise.new(function(resolve, reject)
		-- Call RemoveAsync and remove value from cache:
		local success, err = pcall(self._ds.RemoveAsync, self._ds, key)
		if (success) then
			Log("Successfully deleted key " .. key)
			self:_clearCache(key)
			self.Success:Fire("RemoveAsync", key)
			resolve()
		else
			Log("Failed to delete key " .. key)
			self.Failed:Fire("RemoveAsync", key, err)
			reject(err)
		end
	end)
end


function Data:_update(key, transformFunc)
	Log("Updating " .. key .. "...")
	return Promise.new(function(resolve, reject)
		-- Call UpdateAsync and update cache with returned value:
		local success, value = pcall(self._ds.UpdateAsync, self._ds, key, transformFunc)
		if (success) then
			Log("Successfully updated key " .. key)
			self:_setCache(key, value, true)
			self.Success:Fire("UpdateAsync", key)
			resolve(value)
		else
			Log("Failed to update key " .. key)
			self.Failed:Fire("UpdateAsync", key, value)
			reject(value)
		end
	end)
end


function Data:_getSorted(isAscending, pageSize, minValue, maxValue)
	return Promise.new(function(resolve, reject)
		-- Call GetSortedAsync and return the custom DataStorePages object:
		local success, dsp = pcall(self._ds.GetSortedAsync, self._ds, isAscending, pageSize, minValue, maxValue)
		if (success) then
			resolve(DataStorePages.new(dsp))
		else
			reject(dsp)
		end
	end)
end


-- Retrieve a cached value for the given key:
function Data:_getCache(key)
	return self._cache[key]
end


-- Set an item in the cache and mark clean or dirty:
function Data:_setCache(key, value, isClean)
	if (self._cache[key] ~= value) then
		self._cache[key] = value
		self._dirty[key] = (not isClean)
	end
end


-- Delete an item from the cache:
function Data:_clearCache(key)
	self._cache[key] = nil
	self._dirty[key] = nil
end


-- Check if a key has a value in the cache:
function Data:_cacheExists(key)
	return (self._cache[key] ~= nil)
end


-- Get the number of keys within the cache:
function Data:_countKeysInCache()
	local keyCount = 0
	for _ in pairs(self._cache) do
		keyCount = (keyCount + 1)
	end
	return keyCount
end


---------------------------------------------------------------------------------------------------------------------------
-- PUBLIC METHODS:


function Data:GetRequestBudget(reqType)
	-- See:
		-- https://developer.roblox.com/api-reference/function/DataStoreService/GetRequestBudgetForRequestType
		-- https://developer.roblox.com/api-reference/enum/DataStoreRequestType
		-- https://developer.roblox.com/articles/Datastore-Errors
	return dataStoreService:GetRequestBudgetForRequestType(reqType)
end


function Data:Get(key, defaultVal)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (self:_cacheExists(key)) then
		-- Return the cached value:
		return Promise.Resolve(self:_getCache(key))
	end
	-- Load and return value since it was not in the cache:
	return self:_load(key):Then(function(value)
		if (value == nil and defaultVal ~= nil) then
			value = defaultVal
			if (typeof(defaultVal) == "table") then
				value = tableUtil.Copy(defaultVal)
			end
			return self:Set(key, value):Then(function()
				return value
			end)
		else
			return value
		end
	end)
end


function Data:GetSorted(isAscending, pageSize, minValue, maxValue)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not self._ordered) then
		return Promise.Reject("GetSorted can only be invoked on an ordered data object")
	end
	return self:_getSorted(isAscending, pageSize, minValue, maxValue)
end


function Data:Set(key, value)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	return self:_loadIfNotCached(key):Then(function()
		if (value == nil) then
			return self:_delete(key)
		else
			self:_setCache(key, value)
		end
	end)
end


function Data:Increment(key, increment)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (type(increment) ~= "number") then
		return Promise.Reject("Increment must be a number")
	end
	-- Get the current value, increment it, then set the new value:
	return self:Get(key, 0):Then(function(value)
		if (type(value) ~= "number") then
			error("Cannot increment a non-number value")
			return
		end
		value = (value + increment)
		return self:Set(key, value):Then(function()
			return value
		end)
	end)
end


function Data:Delete(key)
	return self:Set(key, nil)
end


function Data:OnUpdate(key, callback)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (type(callback) ~= "function") then
		return Promise.Reject("Callback must be a function")
	end
	return Promise.new(function(resolve, reject)
		local success, err = pcall(self._ds.OnUpdate, self._ds, key, callback)
		if (success) then
			self.Success:Fire("OnUpdate", key)
			resolve()
		else
			self.Failed:Fire("OnUpdate", key, err)
			reject(err)
		end
	end)
end


function Data:Save(key)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	local cachedVal = self:_getCache(key)
	if (cachedVal == nil) then
		return Promise.Reject("Cannot save key that has not already been loaded via Data:Get(key)")
	end
	return self:_save(key, cachedVal)
end


function Data:SaveAll()
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	-- Collect all 'Save' promises and return them all in a single promise:
	local promises = {}
	for key in pairs(self._cache) do
		promises[#promises + 1] = self:Save(key)
	end
	return Promise.All(promises)
end


function Data:Update(key, transformFunc)
	if (self._destroyed) then
		return Promise.Reject("Data already destroyed")
	end
	if (not CheckKey(key)) then
		return Promise.Reject(KEY_MAX_LEN_ERR)
	end
	if (type(transformFunc) ~= "function") then
		return Promise.Reject("TransformFunction must be a function")
	end
	return self:_update(key, transformFunc)
end


function Data:MarkDirty(key)
	self._dirty[key] = true
end


function Data:Destroy(save)
	Log("Destroying data object:", tostring(self))
	if (self._destroyed or self._destroying) then
		return Promise.Reject("Data already destroyed")
	end
	self._destroying = true
	local savePromise
	if (save) then
		savePromise = self:SaveAll(false, nil)
	else
		savePromise = Promise.Resolve()
	end
	return savePromise:Then(function()
		-- Clear and destroy objects:
		Log("Data successfully destroyed")
		self._destroyed = true
		self._cache = {}
		self._dirty = {}
		self.Failed:Destroy()
		self.Success:Destroy()
		dataPool[self._ds] = nil
	end):Catch(function(err)
		-- Failed to destroy, thus remark as not destroyed &amp; rethrow error:
		Log("   Saving failed")
		self._destroying = false
		error(err)
	end)
end


---------------------------------------------------------------------------------------------------------------------------


function Data:OnClose(handler)
	assert(type(handler) == "function", "OnClose handler must be a function")
	for _,h in ipairs(self._onCloseHandlers) do
		if (h == handler) then
			error("Handler already binded")
		end
	end
	table.insert(self._onCloseHandlers, handler)
end


function Data:Start()

	local gameClosing = false
	local autoSaving = false

	if (game.GameId == 0) then
		Data.IsUsingMockService = true
	elseif (game:GetService("RunService"):IsStudio()) then
		if (not Data.SaveInStudio) then
			Data.IsUsingMockService = true
		else
			-- Verify status of the DataStoreService on startup:
			local success, err = pcall(function()
				dataStoreService:GetDataStore("__aero"):UpdateAsync("dss_api_check", function(v) return v == nil and true or v end)
			end)
			if (not success) then
				-- Error codes: https://developer.roblox.com/articles/Datastore-Errors
				local errCode = tonumber(err:match("^%d+"))
				if (errCode == 502 or errCode == 403) then
					Data.IsUsingMockService = true
				elseif (errCode == 304) then
					error("DataStoreService API check failed on UpdateAsync (request queue full)")
				else
					error("DataStoreService API error " .. errCode or "[Unknown Status]" .. ": " .. err)
				end
			end
		end
	end
	
	local function FireBoundToCloseCallbacks()
		local numBinded = #self._onCloseHandlers
		if (numBinded == 0) then return end
		local bindable = Instance.new("BindableEvent")
		local numCompleted = 0
		for _,func in ipairs(self._onCloseHandlers) do
			HeartbeatSpawn(function()
				local success, err = pcall(func)
				if (not success) then
					warn("Data BindToClose function failed: " .. tostring(err))
				end
				numCompleted = (numCompleted + 1)
				if (numCompleted == numBinded) then
					bindable:Fire()
				end
			end)
		end
		bindable.Event:Wait()
		bindable:Destroy()
	end
	
	local function AutoSaveAllData()
		if (autoSaving) then return end
		autoSaving = true
		local promises = {}
		for _,data in pairs(dataPool) do
			if (data.CanAutoSave) then
				--local budget = dataStoreService:GetRequestBudgetForRequestType(Enum.DataStoreRequestType.SetIncrementAsync)
				--local keys = data:_countKeysInCache()
				local saveAllPromise = data:SaveAll()
				if (not gameClosing) then
					saveAllPromise:Await()
				else
					promises[#promises + 1] = saveAllPromise
				end
			end
		end
		if (#promises == 0) then
			autoSaving = false
		else
			Promise.All(promises):Await()
			autoSaving = false
		end
	end

	if (self.IsUsingMockService) then
		-- Use mock DataStoreService:
		dataStoreService = require(script.MockDataStoreService)
	else
		-- Auto-save all data before server closes:
		game:BindToClose(function()
			gameClosing = true
			FireBoundToCloseCallbacks()
			AutoSaveAllData()
		end)
	end

	-- Destroy player data when player leaves:
	game:GetService("Players").PlayerRemoving:Connect(function(player)
		local data = GetDataFromNameAndScope(PLAYER_DATA_NAME, tostring(player.UserId))
		if (not data) then return end
		wait(self.PlayerLeftSaveInterval)
		if (gameClosing or not data.DestroyOnLeave) then return end
		data:Destroy(true)
	end)

	-- Auto-save cycle:
	HeartbeatSpawn(function()
		while (true) do
			wait(self.AutoSaveInterval)
			if (gameClosing) then break end
			AutoSaveAllData()
		end
	end)

end


function Data:Init()
	Promise = self.Shared.Promise
	tableUtil = self.Shared.TableUtil
end


function Data:__tostring()
	return ("Data (Name=%s, Scope=%s, Ordered=%s)"):format(self.Name, self.Scope, self._ordered and "Yes" or "No")
end


return Data</string>
          </Properties>
          <Item class="ModuleScript" referent="27">
            <Properties>
              <string name="Name">MockDataStoreService</string>
              <string name="Source">-- Mock DataStoreService
-- Stephen Leitnick
-- August 20, 2014


--[[
	
	USAGE EXAMPLE:
	
		--------
		local dataStoreService = game:GetService("DataStoreService")
		
		-- Mock service if the game is offline:
		if (game.PlaceId == 0) then
			dataStoreService = require(game.ServerStorage.MockDataStoreService)
		end
		
		-- dataStoreService will act exactly like the real one
		--------
	
	The mocked data store service should function exactly like the
	real service. What the mocked service does is "override" the
	core methods, such as GetAsync. If you try to index a property
	that hasn't been overridden (such as dataStoreService.Name), it
	will reference the actual property in the real dataStoreService.
	
	NOTE:
		This has been created based off of the DataStoreService on
		August 20, 2014. If a change has been made to the service,
		this mocked version will not reflect the changes.
	
--]]



local DataStoreService = {}
local API = {}
local MT = {}


-----------------------------------------------------------------------------------------------------------

local realDataStoreService = game:GetService("DataStoreService")
local allStores = {}

if (game:GetService("Players").LocalPlayer) then
	warn("Mocked DataStoreService is functioning on the client: The real DataStoreService will not work on the client")
end


-----------------------------------------------------------------------------------------------------------
-- API:

function API:GetDataStore(name, scope)
	assert(type(name) == "string", "DataStore name must be a string; got" .. type(name))
	assert(type(scope) == "string" or scope == nil, "DataStore scope must be a string; got" .. type(scope))
	scope = (scope or "global")
	if (allStores[scope] and allStores[scope][name]) then
		return allStores[scope][name]
	end
	local data = {}
	local d = {}
	local updateListeners = {}
	function d.SetAsync(_s, k, v)
		assert(v ~= nil, "Value cannot be nil")
		data[k] = v
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(v) end)
			end
		end
	end
	function d.UpdateAsync(_s, k, func)
		local v = func(data[k])
		assert(v ~= nil, "Value cannot be nil")
		data[k] = v
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(v) end)
			end
		end
	end
	function d.GetAsync(_s, k)
		return data[k]
	end
	function d.RemoveAsync(_s, k)
		data[k] = nil
		if (updateListeners[k]) then
			for _,f in ipairs(updateListeners[k]) do
				spawn(function() f(nil) end)
			end
		end
	end
	function d.IncrementAsync(_s, k, delta)
		if (delta == nil) then delta = 1 end
		assert(type(delta) == "number", "Can only increment numbers")
		_s:UpdateAsync(k, function(num)
			if (num == nil) then
				return num
			end
			assert(type(num) == "number", "Can only increment numbers")
			return (num + delta)
		end)
	end
	function d.OnUpdate(_s, k, onUpdateFunc)
		assert(type(onUpdateFunc) == "function", "Update function argument must be a function")
		if (not updateListeners[k]) then
			updateListeners[k] = {onUpdateFunc}
		else
			table.insert(updateListeners[k], onUpdateFunc)
		end
	end
	if (not allStores[scope]) then
		allStores[scope] = {}
	end
	allStores[scope][name] = d
	return d
end


function API:GetGlobalDataStore()
	return self:GetDataStore("global", "global")
end


function API:GetOrderedDataStore(name, scope)
	local dataStore = self:GetDataStore(name, scope)
	local allData = {}
	local d = {}
	function d.GetAsync(_s, k)
		return dataStore:GetAsync(k)
	end
	function d.SetAsync(_s, k, v)
		assert(type(v) == "number", "Value must be a number")
		dataStore:SetAsync(k, v)
		allData[k] = v
	end
	function d.UpdateAsync(_s, k, func)
		dataStore:UpdateAsync(k, function(oldValue)
			local v = func(oldValue)
			assert(type(v) == "number", "Value must be a number")
			allData[k] = v
			return v
		end)
	end
	function d.IncrementAsync(_s, k, delta)
		dataStore:IncrementAsync(k, delta)
		allData[k] = ((allData[k] or 0) + delta)
	end
	function d.RemoveAsync(_s, k)
		dataStore:RemoveAsync(k)
		allData[k] = nil
	end
	function d.GetSortedAsync(_s, isAscending, pageSize, minValue, maxValue)
		assert(type(pageSize) == "number" and math.floor(pageSize) > 0, "PageSize must be an integer and greater than 0")
		assert(minValue == nil or type(minValue) == "number", "MinValue must be a number")
		assert(maxValue == nil or type(maxValue) == "number", "MaxValue must be a number")
		if (minValue and maxValue) then
			assert(minValue &lt;= maxValue, "MinValue must be less or equal to MaxValue")
		end
		local data = {}
		for k,v in pairs(allData) do
			local pass = ((not minValue or v >= minValue) and (not maxValue or v &lt;= maxValue))
			if (pass) then
				table.insert(data, {key = k, value = v})
			end
		end
		table.sort(data,
			(isAscending and
				function(a, b) return (a.value &lt; b.value) end
			or
				function(a, b) return (b.value &lt; a.value) end
			)
		)
		pageSize = math.floor(pageSize)
		local pages = {IsFinished = false}
		for i,v in pairs(data) do
			local pageNum = math.ceil(i / pageSize)
			local page = pages[pageNum]
			if (not page) then
				page = {}
				pages[pageNum] = page
			end
			local index = (((i - 1) % pageSize) + 1)
			page[index] = v
		end
		do
			local currentPage = 1
			function pages.GetCurrentPage(p)
				return p[currentPage]
			end
			function pages.AdvanceToNextPageAsync(p)
				local numPages = #pages
				if (currentPage &lt; numPages) then
					currentPage = (currentPage + 1)
				end
				p.IsFinished = (currentPage >= numPages)
			end
		end
		return pages
	end
	return d
end


function API:GetRequestBudgetForRequestType(requestType)
	return realDataStoreService:GetRequestBudgetForRequestType(requestType)
end


-----------------------------------------------------------------------------------------------------------
-- Metatable:

MT.__metatable = true
MT.__index = function(_tbl, index)
	return (API[index] or realDataStoreService[index])
end
MT.__newindex = function()
	error("Cannot edit MockDataStoreService")
end
setmetatable(DataStoreService, MT)

-----------------------------------------------------------------------------------------------------------

return DataStoreService</string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="28">
          <Properties>
            <string name="Name">ProfileService</string>
            <string name="Source">-- ProfileService
-- Mad Studios
-- https://github.com/MadStudioRoblox/ProfileService
-- Modified for use within AeroGameFramework


--[[
{Madwork}

-[ProfileService]---------------------------------------
	(STANDALONE VERSION)
	DataStore profiles - universal session-locked savable table API
	
	Official documentation:
		https://madstudioroblox.github.io/ProfileService/

	DevForum discussion:
		https://devforum.roblox.com/t/ProfileService/667805
	
	WARNINGS FOR "Profile.Data" VALUES:
		More information on https://madstudioroblox.github.io/ProfileService/troubleshooting/
		! Do not store NaN values
	 	! Do not create array tables with non-sequential indexes - attempting to replicate such tables will result in an error;
		! Do not create mixed tables (some values indexed by number and others by string key), as only
		     the data indexed by number will be replicated.
		! Do not index tables by anything other than numbers and strings.
		! Do not reference Roblox Instances
		! Do not reference userdata (Vector3, Color3, CFrame...) - Serialize userdata before referencing
		! Do not reference functions
		
	WARNING: Calling ProfileStore:LoadProfileAsync() with a "profile_key" which wasn't released in the SAME SESSION will result
		in an error! If you want to "ProfileStore:LoadProfileAsync()" instead of using the already loaded profile, :Release()
		the old Profile object.
		
	Members:
	
		ProfileService.ServiceLocked         [bool]
		
		ProfileService.IssueSignal           [ScriptSignal](error_message)
		ProfileService.CorruptionSignal      [ScriptSignal](profile_store_name, profile_key)
		ProfileService.CriticalStateSignal   [ScriptSignal](is_critical_state)
	
	Functions:
	
		ProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]
		
		* Parameter description for "ProfileService.GetProfileStore()":
		
			profile_store_name   [string] -- DataStore name
			profile_template     []:
				{}                        [table] -- Profiles will default to given table (hard-copy) when no data was saved previously
				nil                       [nil] -- ProfileStore:LoadProfileAsync() method will be locked
				
	Members [ProfileStore]:
	
		ProfileStore.Mock   [ProfileStore] -- Reflection of ProfileStore methods, but the methods will use a mock DataStore
		
	Methods [ProfileStore]:
	
		ProfileStore:LoadProfileAsync(profile_key, not_released_handler) --> [Profile / nil] not_released_handler(place_id, game_job_id)
		ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
			-- Returns GlobalUpdates object if update was successful, otherwise returns nil
		
		ProfileStore:ViewProfileAsync(profile_key) --> [Profile / nil] -- Notice #1: Profile object methods will not be available;
			Notice #2: Profile object members will be nil (Profile.Data = nil, Profile.MetaData = nil) if the profile hasn't
			been created, with the exception of Profile.GlobalUpdates which could be empty or populated by
			ProfileStore:GlobalUpdateProfileAsync()
			
		ProfileStore:WipeProfileAsync(profile_key) --> is_wipe_successful [bool] -- Completely wipes out profile data from the
			DataStore / mock DataStore with no way to recover it.
		
		* Parameter description for "ProfileStore:LoadProfileAsync()":
		
			profile_key            [string] -- DataStore key
			not_released_handler = "ForceLoad" -- Force loads profile on first call
			OR
			not_released_handler = "Steal" -- Steals the profile ignoring it's session lock
			OR
			not_released_handler   [function] (place_id, game_job_id) --> [string] ("Repeat" / "Cancel" / "ForceLoad")
				-- "not_released_handler" will be triggered in cases where the profile is not released by a session. This
				function may yield for as long as desirable and must return one of three string values:
					["Repeat"] - ProfileService will repeat the profile loading proccess and may trigger the release handler again
					["Cancel"] - ProfileStore:LoadProfileAsync() will immediately return nil
					["ForceLoad"] - ProfileService will repeat the profile loading call, but will return Profile object afterwards
						and release the profile for another session that has loaded the profile
					["Steal"] - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying
						a session lock for this session.
						
		* Parameter description for "ProfileStore:GlobalUpdateProfileAsync()":
		
			profile_key      [string] -- DataStore key
			update_handler   [function] (GlobalUpdates) -- This function gains access to GlobalUpdates object methods
				(update_handler can't yield)
		
	Members [Profile]:
	
		Profile.Data            [table] -- Writable table that gets saved automatically and once the profile is released
		Profile.MetaData        [table] (Read-only) -- Information about this profile
		
			Profile.MetaData.ProfileCreateTime   [number] (Read-only) -- os.time() timestamp of profile creation
			Profile.MetaData.SessionLoadCount    [number] (Read-only) -- Amount of times the profile was loaded
			Profile.MetaData.ActiveSession       [table] (Read-only) {place_id, game_job_id} / nil -- Set to a session link if a
				game session is currently having this profile loaded; nil if released
			Profile.MetaData.MetaTags            [table] {["tag_name"] = tag_value, ...} -- Saved and auto-saved just like Profile.Data
			Profile.MetaData.MetaTagsLatest      [table] (Read-only) -- Latest version of MetaData.MetaTags that was definetly saved to DataStore
				(You can use Profile.MetaData.MetaTagsLatest for product purchase save confirmation, but create a system to clear old tags after
				they pile up)
		
		Profile.GlobalUpdates   [GlobalUpdates]
		
	Methods [Profile]:
	
		-- SAFE METHODS - Will not error after profile expires:
		Profile:IsActive() --> [bool] -- Returns true while the profile is active and can be written to
			
		Profile:GetMetaTag(tag_name) --> value
		
		Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil) -- WARNING: Profiles can be released externally if another session
			force-loads this profile - use :ListenToRelease() to handle player leaving cleanup.
			
		Profile:Release() -- Call after the session has finished working with this profile
			e.g., after the player leaves (Profile object will become expired) (Does not yield)
		
		-- DANGEROUS METHODS - Will error if the profile is expired:
		-- MetaTags - Save and read values stored in Profile.MetaData for storing info about the
			profile itself like "Profile:SetMetaTag("FirstTimeLoad", true)"
		Profile:SetMetaTag(tag_name, value)
		
		Profile:Save() -- Call to quickly progress global update state or to speed up save validation processes (Does not yield)

		
	Methods [GlobalUpdates]:
	
	-- ALWAYS AVAILABLE:
		GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
		GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
		
	-- ONLY ACCESSIBLE THROUGH "Profile.GlobalUpdates":
		GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
		GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
		-- WARNING: GlobalUpdates:LockUpdate() and GlobalUpdates:ClearLockedUpdate() will error after profile expires
		GlobalUpdates:LockActiveUpdate(update_id)
		GlobalUpdates:ClearLockedUpdate(update_id)
		
	-- AVAILABLE INSIDE "update_handler" DURING A ProfileStore:GlobalUpdateProfileAsync() CALL
		GlobalUpdates:AddActiveUpdate(update_data)
		GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
		GlobalUpdates:ClearActiveUpdate(update_id)
		
--]]

local SETTINGS = {

	AutoSaveProfiles = 30, -- Seconds (This value may vary - ProfileService will split the auto save load evenly in the given time)
	LoadProfileRepeatDelay = 15, -- Seconds between successive DataStore calls for the same key
	ForceLoadMaxSteps = 4, -- Steps taken before ForceLoad request steals the active session for a profile
	AssumeDeadSessionLock = 30 * 60, -- (seconds) If a profile hasn't been updated for 30 minutes, assume the session lock is dead
		-- As of writing, os.time() is not completely reliable, so we can only assume session locks are dead after a significant amount of time.
	
	IssueCountForCriticalState = 5, -- Issues to collect to announce critical state
	IssueLast = 120, -- Seconds
	CriticalStateLast = 120, -- Seconds
	
}

local Madwork -- Standalone Madwork reference for portable version of ProfileService
do
	-- ScriptConnection object:
	local ScriptConnection = {
		-- _listener = function -- [function]
		-- _listener_table = {} -- [table] -- Table from which the function entry will be removed
	}
	
	function ScriptConnection:Disconnect()
		local listener = self._listener
		if listener ~= nil then
			local listener_table = self._listener_table
			for i = 1, #listener_table do
				if listener == listener_table[i] then
					table.remove(listener_table, i)
					break
				end
			end
			self._listener = nil
		end
	end
	
	function ScriptConnection.NewScriptConnection(listener_table, listener) --> [ScriptConnection]
		return {
			_listener = listener,
			_listener_table = listener_table,
			Disconnect = ScriptConnection.Disconnect
		}
	end
	
	-- ScriptSignal object:
	local ScriptSignal = {
		-- _listeners = {}
	}
	
	function ScriptSignal:Connect(listener) --> [ScriptConnection]
		if type(listener) ~= "function" then
			error("[ScriptSignal]: Only functions can be passed to ScriptSignal:Connect()")
		end
		table.insert(self._listeners, listener)
		return {
			_listener = listener,
			_listener_table = self._listeners,
			Disconnect = ScriptConnection.Disconnect
		}
	end
	
	function ScriptSignal:Fire(...)
		for _, listener in ipairs(self._listeners) do
			listener(...)
		end
	end
	
	function ScriptSignal.NewScriptSignal() --> [ScriptSignal]
		return {
			_listeners = {},
			Connect = ScriptSignal.Connect,
			Fire = ScriptSignal.Fire
		}
	end
	
	local RunService = game:GetService("RunService")
	local Heartbeat = RunService.Heartbeat
	
	Madwork = {
		NewScriptSignal = ScriptSignal.NewScriptSignal,
		NewScriptConnection = ScriptConnection.NewScriptConnection,
		HeartbeatWait = function(wait_time) --> time_elapsed
			if wait_time == nil or wait_time == 0 then
				return Heartbeat:Wait()
			else
				local time_elapsed = 0
				while time_elapsed &lt;= wait_time do
					local time_waited = Heartbeat:Wait()
					time_elapsed = time_elapsed + time_waited
				end
				return time_elapsed
			end
		end,
		ConnectToOnClose = function(task, run_in_studio_mode)
			if game:GetService("RunService"):IsStudio() == false or run_in_studio_mode == true then
				game:BindToClose(task)
			end
		end,
	}
end

----- Service Table -----

local ProfileService = {

	ServiceLocked = false, -- Set to true once the server is shutting down
	
	IssueSignal = Madwork.NewScriptSignal(), -- (error_message) -- Fired when a DataStore API call throws an error
	CorruptionSignal = Madwork.NewScriptSignal(), -- (profile_store_name, profile_key) -- Fired when DataStore key returns a value that has
		-- all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a noon table value
	
	CriticalState = false, -- Set to true while DataStore service is throwing too many errors
	CriticalStateSignal = Madwork.NewScriptSignal(), -- (is_critical_state) -- Fired when CriticalState is set to true
		-- (You may alert players with this, or set up analytics)
	
	ServiceIssueCount = 0,

	_active_profile_stores = {
		--[[
			{
				_profile_store_name = "", -- [string] -- DataStore name
				_profile_template = {} / nil, -- [table / nil]
				_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
				
				_loaded_profiles = {
					[profile_key] = {
						Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
						MetaData = {}, -- [table] -- Updated with every auto-save
						GlobalUpdates = {, -- [GlobalUpdates]
							_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
							_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
							_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
							
							_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]
							_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]
							
							_profile = Profile / nil, -- [Profile / nil]
							
							_update_handler_mode = true / nil, -- [bool / nil]
						}
						
						_profile_store = ProfileStore, -- [ProfileStore]
						_profile_key = "", -- [string]
						
						_release_listeners = {listener, ...} / nil, -- [table / nil]
						
						_view_mode = true / nil, -- [bool / nil]
						
						_load_timestamp = tick(),
						
						_is_user_mock = false, -- ProfileStore.Mock
					},
					...
				},
				_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
				
				_mock_loaded_profiles = {[profile_key] = Profile, ...},
				_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
			},
			...
		--]]
	},
	
	_auto_save_list = { -- loaded profile table which will be circularly auto-saved
		--[[
			Profile,
			...
		--]]
	},
	
	_issue_queue = {}, -- [table] {issue_tick, ...}
	_critical_state_start = 0, -- [number] 0 = no critical state / tick() = critical state start
	
	-- Debug:
	_mock_data_store = {},
	_user_mock_data_store = {},
	
	_use_mock_data_store = false,
	
}

--[[
	Saved profile structure:
	
	DataStoreProfile = {
		Data = {},
		MetaData = {
			ProfileCreateTime = 0,
			SessionLoadCount = 0,
			ActiveSession = {place_id, game_job_id} / nil,
			ForceLoadSession = {place_id, game_job_id} / nil,
			MetaTags = {},
			LastUpdate = 0, -- os.time()
		},
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
	
	OR
	
	DataStoreProfile = {
		GlobalUpdates = {
			update_index,
			{
				{update_id, version_id, update_locked, update_data},
				...
			}
		},
	}
--]]

----- Private Variables -----

local ActiveProfileStores = ProfileService._active_profile_stores
local AutoSaveList = ProfileService._auto_save_list
local IssueQueue = ProfileService._issue_queue

local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")

local PlaceId = game.PlaceId
local JobId = game.JobId

local AutoSaveIndex = 1 -- Next profile to auto save
local LastAutoSave = tick()

local LoadIndex = 0

local ActiveProfileLoadJobs = 0 -- Number of active threads that are loading in profiles
local ActiveProfileSaveJobs = 0 -- Number of active threads that are saving profiles

local CriticalStateStart = 0 -- tick()

local IsStudio = RunService:IsStudio()
local UseMockDataStore = false
local MockDataStore = ProfileService._mock_data_store -- Mock data store used when API access is disabled

local UserMockDataStore = ProfileService._user_mock_data_store -- Separate mock data store accessed via ProfileStore.Mock
local UseMockTag = {}

----- Utils -----

local function DeepCopyTable(t)
	local copy = {}
	for key, value in pairs(t) do
		if type(value) == "table" then
			copy[key] = DeepCopyTable(value)
		else
			copy[key] = value
		end
	end
	return copy
end

----- Private functions -----

local function RegisterIssue(error_message) -- Called when a DataStore API call errors
	warn("[ProfileService]: DataStore API error - \"" .. tostring(error_message) .. "\"")
	table.insert(IssueQueue, tick()) -- Adding issue time to queue
	ProfileService.IssueSignal:Fire(tostring(error_message))
end

local function RegisterCorruption(profile_store_name, profile_key) -- Called when a corrupted profile is loaded
	warn("[ProfileService]: Profile corruption - ProfileStore = \"" .. profile_store_name .. "\", Key = \"" .. profile_key .. "\"")
	ProfileService.CorruptionSignal:Fire(profile_store_name, profile_key)
end

local function MockUpdateAsync(mock_data_store, profile_store_name, key, transform_function)
	local profile_store = mock_data_store[profile_store_name]
	if profile_store == nil then
		profile_store = {}
		mock_data_store[profile_store_name] = profile_store
	end
	local transform = transform_function(profile_store[key])
	if transform == nil then
		return nil
	else
		profile_store[key] = DeepCopyTable(transform)
		return DeepCopyTable(profile_store[key])
	end
end

local function IsThisSession(session_tag)
	return session_tag[1] == PlaceId and session_tag[2] == JobId
end

--[[
update_settings = {
	ExistingProfileHandle = function(latest_data),
	MissingProfileHandle = function(latest_data),
	EditProfile = function(lastest_data),
	
	WipeProfile = nil / true,
}
--]]
local function StandardProfileUpdateAsyncDataStore(profile_store, profile_key, update_settings, is_user_mock)
	local loaded_data
	local wipe_status = false
	local success, error_message = pcall(function()
		if update_settings.WipeProfile ~= true then
			local transform_function = function(latest_data)
				if latest_data == "PROFILE_WIPED" then
					latest_data = nil -- Profile was previously wiped - ProfileService will act like it was empty
				end
				
				local missing_profile = false
				local data_corrupted = false
				local global_updates_data = {0, {}}
				
				if latest_data == nil then
					missing_profile = true
				elseif type(latest_data) ~= "table" then
					missing_profile = true
					data_corrupted = true
				end
				
				if type(latest_data) == "table" then
					-- Case #1: Profile was loaded
					if type(latest_data.Data) == "table" and
						type(latest_data.MetaData) == "table" and
						type(latest_data.GlobalUpdates) == "table" then
						
						latest_data.WasCorrupted = false -- Must be set to false if set previously
						global_updates_data = latest_data.GlobalUpdates
						if update_settings.ExistingProfileHandle ~= nil then
							update_settings.ExistingProfileHandle(latest_data)
						end
					-- Case #2: Profile was not loaded but GlobalUpdate data exists
					elseif latest_data.Data == nil and
						latest_data.MetaData == nil and
						type(latest_data.GlobalUpdates) == "table" then
						
						latest_data.WasCorrupted = false -- Must be set to false if set previously
						global_updates_data = latest_data.GlobalUpdates
						missing_profile = true
					else
						missing_profile = true
						data_corrupted = true
					end
				end
				
				-- Case #3: Profile was not created or corrupted and no GlobalUpdate data exists
				if missing_profile == true then
					latest_data = {
						-- Data = nil,
						-- MetaData = nil,
						GlobalUpdates = global_updates_data,
					}
					if update_settings.MissingProfileHandle ~= nil then
						update_settings.MissingProfileHandle(latest_data)
					end
				end
				
				-- Editing profile:
				if update_settings.EditProfile ~= nil then
					update_settings.EditProfile(latest_data)
				end
				
				-- Data corruption handling (Silently override with empty profile) (Also run Case #1)
				if data_corrupted == true then
					latest_data.WasCorrupted = true -- Temporary tag that will be removed on first save
				end
				
				return latest_data
			end
			if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
				loaded_data = MockUpdateAsync(UserMockDataStore, profile_store._profile_store_name, profile_key, transform_function)
				Madwork.HeartbeatWait() -- Simulate API call yield
			elseif UseMockDataStore == true then -- Used when API access is disabled
				loaded_data = MockUpdateAsync(MockDataStore, profile_store._profile_store_name, profile_key, transform_function)
				Madwork.HeartbeatWait() -- Simulate API call yield
			else
				loaded_data = profile_store._global_data_store:UpdateAsync(profile_key, transform_function)
			end
		else
			if is_user_mock == true then -- Used when the profile is accessed through ProfileStore.Mock
				local p_store = UserMockDataStore[profile_store._profile_store_name]
				if p_store ~= nil then
					p_store[profile_key] = nil
				end
				wipe_status = true
				Madwork.HeartbeatWait() -- Simulate API call yield
			elseif UseMockDataStore == true then -- Used when API access is disabled
				local p_store = MockDataStore[profile_store._profile_store_name]
				if p_store ~= nil then
					p_store[profile_key] = nil
				end
				wipe_status = true
				Madwork.HeartbeatWait() -- Simulate API call yield
			else
				loaded_data = profile_store._global_data_store:UpdateAsync(profile_key, function()
					return "PROFILE_WIPED" -- It's impossible to set DataStore keys to nil after they have been set
				end)
				if loaded_data == "PROFILE_WIPED" then
					wipe_status = true
				end
			end
		end
	end)
	if update_settings.WipeProfile == true then
		return wipe_status
	elseif success == true and type(loaded_data) == "table" then
		-- Corruption handling:
		if loaded_data.WasCorrupted == true then
			RegisterCorruption(profile_store._profile_store_name, profile_key)
		end
		-- Return loaded_data:
		return loaded_data
	else
		RegisterIssue((error_message ~= nil) and error_message or "Undefined error")
		-- Return nothing:
		return nil
	end
end

local function RemoveProfileFromAutoSave(profile)
	local auto_save_index = table.find(AutoSaveList, profile)
	if auto_save_index ~= nil then
		table.remove(AutoSaveList, auto_save_index)
		if auto_save_index &lt; AutoSaveIndex then
			AutoSaveIndex = AutoSaveIndex - 1 -- Table contents were moved left before AutoSaveIndex so move AutoSaveIndex left as well
		end
		if AutoSaveList[AutoSaveIndex] == nil then -- AutoSaveIndex was at the end of the AutoSaveList - reset to 1
			AutoSaveIndex = 1
		end
	end
end

local function AddProfileToAutoSave(profile) -- Notice: Makes sure this profile isn't auto-saved too soon
	-- Add at AutoSaveIndex and move AutoSaveIndex right:
	table.insert(AutoSaveList, AutoSaveIndex, profile)
	if #AutoSaveList > 1 then
		AutoSaveIndex = AutoSaveIndex + 1
	elseif #AutoSaveList == 1 then
		-- First profile created - make sure it doesn't get immediately auto saved:
		LastAutoSave = tick()
	end
end

local function ReleaseProfileInternally(profile)
	-- 1) Remove profile object from ProfileService references: --
	-- Clear reference in ProfileStore:
	local profile_store = profile._profile_store
	local loaded_profiles = profile._is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
	loaded_profiles[profile._profile_key] = nil
	if next(profile_store._loaded_profiles) == nil and next(profile_store._mock_loaded_profiles) == nil then -- ProfileStore has turned inactive
		local index = table.find(ActiveProfileStores, profile_store)
		if index ~= nil then
			table.remove(ActiveProfileStores, index)
		end
	end
	-- Clear auto update reference:
	RemoveProfileFromAutoSave(profile)
	-- 2) Trigger release listeners: --
	local place_id
	local game_job_id
	local active_session = profile.MetaData.ActiveSession
	if active_session ~= nil then
		place_id = active_session[1]
		game_job_id = active_session[2]
	end
	for _, listener in ipairs(profile._release_listeners) do
		listener(place_id, game_job_id)
	end
	profile._release_listeners = {}
end

local function CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
	local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
	local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
	local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
	-- "old_" or "new_" global_updates_data = {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	for _, new_global_update in ipairs(new_global_updates_data[2]) do
		-- Find old global update with the same update_id:
		local old_global_update
		for _, global_update in ipairs(old_global_updates_data[2]) do
			if global_update[1] == new_global_update[1] then
				old_global_update = global_update
				break
			end
		end
		-- A global update is new when it didn't exist before or its version_id or update_locked state changed:
		local is_new = false
		if old_global_update == nil or new_global_update[2] > old_global_update[2] or new_global_update[3] ~= old_global_update[3] then
			is_new = true
		end
		if is_new == true then
			-- Active global updates:
			if new_global_update[3] == false then
				-- Check if update is not pending to be locked: (Preventing firing new active update listeners more than necessary)
				local is_pending_lock = false
				for _, update_id in ipairs(pending_update_lock) do
					if new_global_update[1] == update_id then
						is_pending_lock = true
						break
					end
				end
				if is_pending_lock == false then
					-- Trigger new active update listeners:
					for _, listener in ipairs(global_updates_object._new_active_update_listeners) do
						listener(new_global_update[1], new_global_update[4])
					end
				end
			end
			-- Locked global updates:
			if new_global_update[3] == true then
				-- Check if update is not pending to be cleared: (Preventing firing new locked update listeners after marking a locked update for clearing)
				local is_pending_clear = false
				for _, update_id in ipairs(pending_update_clear) do
					if new_global_update[1] == update_id then
						is_pending_clear = true
						break
					end
				end
				if is_pending_clear == false then
					-- Trigger new locked update listeners:
					for _, listener in ipairs(global_updates_object._new_locked_update_listeners) do
						listener(new_global_update[1], new_global_update[4])
						-- Check if listener marked the update to be cleared:
						-- Normally there should be only one listener per profile for new locked global updates, but
						-- in case several listeners are connected we will not trigger more listeners after one listener
						-- marks the locked global update to be cleared.
						for _, update_id in ipairs(pending_update_clear) do
							if new_global_update[1] == update_id then
								is_pending_clear = true
								break
							end
						end
						if is_pending_clear == true then
							break
						end
					end
				end
			end
		end
	end
end

local function SaveProfileAsync(profile, release_from_session)
	if type(profile.Data) ~= "table" then
		RegisterCorruption(profile._profile_store._profile_store_name, profile._profile_key)
		error("[ProfileService]: PROFILE DATA CORRUPTED DURING RUNTIME! ProfileStore = \"" .. profile._profile_store._profile_store_name .. "\", Key = \"" .. profile._profile_key .. "\"")
	end
	if release_from_session == true then
		ReleaseProfileInternally(profile)
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs + 1
	local loaded_data = StandardProfileUpdateAsyncDataStore(
		profile._profile_store,
		profile._profile_key,
		{
			ExistingProfileHandle = nil,
			MissingProfileHandle = nil,
			EditProfile = function(latest_data)
				-- 1) Check if this session still owns the profile: --
				local active_session = latest_data.MetaData.ActiveSession
				local force_load_session = latest_data.MetaData.ForceLoadSession
				local session_owns_profile = false
				local force_load_pending = false
				if type(active_session) == "table" then
					session_owns_profile = IsThisSession(active_session)
				end
				if type(force_load_session) == "table" then
					force_load_pending = not IsThisSession(force_load_session)
				end
				
				if session_owns_profile == true then -- We may only edit the profile if this session has ownership of the profile
					-- 2) Manage global updates: --
					local latest_global_updates_data = latest_data.GlobalUpdates -- {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
					local latest_global_updates_list = latest_global_updates_data[2]
					
					local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
					local pending_update_lock = global_updates_object._pending_update_lock -- {update_id, ...}
					local pending_update_clear = global_updates_object._pending_update_clear -- {update_id, ...}
					-- Active update locking:
					for i = 1, #latest_global_updates_list do
						for _, lock_id in ipairs(pending_update_lock) do
							if latest_global_updates_list[i][1] == lock_id then
								latest_global_updates_list[i][3] = true
								break
							end
						end
					end
					-- Locked update clearing:
					for _, clear_id in ipairs(pending_update_clear) do
						for i = 1, #latest_global_updates_list do
							if latest_global_updates_list[i][1] == clear_id and latest_global_updates_list[i][3] == true then
								table.remove(latest_global_updates_list, i)
								break
							end
						end
					end
					-- 3) Save profile data: --
					latest_data.Data = profile.Data
					latest_data.MetaData.MetaTags = profile.MetaData.MetaTags -- MetaData.MetaTags is the only actively savable component of MetaData
					latest_data.MetaData.LastUpdate = os.time()
					if release_from_session == true or force_load_pending == true then
						latest_data.MetaData.ActiveSession = nil
					end
				end
			end,
		},
		profile._is_user_mock
	)
	if loaded_data ~= nil then
		-- 4) Set latest data in profile: --
		-- Setting global updates:
		local global_updates_object = profile.GlobalUpdates -- [GlobalUpdates]
		local old_global_updates_data = global_updates_object._updates_latest
		local new_global_updates_data = loaded_data.GlobalUpdates
		global_updates_object._updates_latest = new_global_updates_data
		-- Setting MetaData:
		local keep_session_meta_tag_reference = profile.MetaData.MetaTags
		profile.MetaData = loaded_data.MetaData
		profile.MetaData.MetaTagsLatest = profile.MetaData.MetaTags
		profile.MetaData.MetaTags = keep_session_meta_tag_reference
		-- 5) Check if session still owns the profile: --
		local active_session = loaded_data.MetaData.ActiveSession
		--local force_load_session = loaded_data.MetaData.ForceLoadSession
		local session_owns_profile = false
		if type(active_session) == "table" then
			session_owns_profile = IsThisSession(active_session)
		end
		local is_active = profile:IsActive()
		if session_owns_profile == true then
			-- 6) Check for new global updates: --
			if is_active == true then -- Profile could've been released before the saving thread finished
				CheckForNewGlobalUpdates(profile, old_global_updates_data, new_global_updates_data)
			end
		else
			-- Session no longer owns the profile:
			-- 7) Release profile if it hasn't been released yet: --
			if is_active == true then
				ReleaseProfileInternally(profile)
			end
		end
	end
	ActiveProfileSaveJobs = ActiveProfileSaveJobs - 1
end

----- Public functions -----

-- GlobalUpdates object:

local GlobalUpdates = {
	--[[
		_updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
		_pending_update_lock = {update_id, ...} / nil, -- [table / nil]
		_pending_update_clear = {update_id, ...} / nil, -- [table / nil]
		
		_new_active_update_listeners = {listener, ...} / nil, -- [table / nil]
		_new_locked_update_listeners = {listener, ...} / nil, -- [table / nil]
		
		_profile = Profile / nil, -- [Profile / nil]
		
		_update_handler_mode = true / nil, -- [bool / nil]
	--]]
}
GlobalUpdates.__index = GlobalUpdates

-- ALWAYS PUBLIC:
function GlobalUpdates:GetActiveUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == false then
			local is_pending_lock = false
			if self._pending_update_lock ~= nil then
				for _, update_id in ipairs(self._pending_update_lock) do
					if global_update[1] == update_id then
						is_pending_lock = true -- Exclude global updates pending to be locked
						break
					end
				end
			end
			if is_pending_lock == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

function GlobalUpdates:GetLockedUpdates() --> [table] {{update_id, update_data}, ...}
	local query_list = {}
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[3] == true then
			local is_pending_clear = false
			if self._pending_update_clear ~= nil then
				for _, update_id in ipairs(self._pending_update_clear) do
					if global_update[1] == update_id then
						is_pending_clear = true -- Exclude global updates pending to be cleared
						break
					end
				end
			end
			if is_pending_clear == false then
				table.insert(query_list, {global_update[1], global_update[4]})
			end
		end
	end
	return query_list
end

-- ONLY WHEN FROM "Profile.GlobalUpdates":
function GlobalUpdates:ListenToNewActiveUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewActiveUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_active_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	table.insert(self._new_active_update_listeners, listener)
	return Madwork.NewScriptConnection(self._new_active_update_listeners, listener)
end

function GlobalUpdates:ListenToNewLockedUpdate(listener) --> [ScriptConnection] listener(update_id, update_data)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in GlobalUpdates:ListenToNewLockedUpdate()")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't listen to new global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._new_locked_update_listeners == nil then
		error("[ProfileService]: Can't listen to new global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		return { -- Do not connect listener if the profile is expired
			Disconnect = function() end,
		}
	end
	-- Connect listener:
	table.insert(self._new_locked_update_listeners, listener)
	return Madwork.NewScriptConnection(self._new_locked_update_listeners, listener)
end

function GlobalUpdates:LockActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't lock active global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_lock == nil then
		error("[ProfileService]: Can't lock active global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't lock active global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_lock = false
		for _, lock_update_id in ipairs(self._pending_update_lock) do
			if update_id == lock_update_id then
				is_pending_lock = true -- Exclude global updates pending to be locked
				break
			end
		end
		if is_pending_lock == false and global_update_exists[3] == false then -- Avoid id duplicates in _pending_update_lock
			table.insert(self._pending_update_lock, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearLockedUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	local profile = self._profile
	if self._update_handler_mode == true then
		error("[ProfileService]: Can't clear locked global updates in ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._pending_update_clear == nil then
		error("[ProfileService]: Can't clear locked global updates in view mode")
	elseif profile:IsActive() == false then -- Check if profile is expired
		error("[ProfileService]: PROFILE EXPIRED - Can't clear locked global updates")
	end
	-- Check if global update exists with given update_id
	local global_update_exists = nil
	for _, global_update in ipairs(self._updates_latest[2]) do
		if global_update[1] == update_id then
			global_update_exists = global_update
			break
		end
	end
	if global_update_exists ~= nil then
		local is_pending_clear = false
		for _, clear_update_id in ipairs(self._pending_update_clear) do
			if update_id == clear_update_id then
				is_pending_clear = true -- Exclude global updates pending to be cleared
				break
			end
		end
		if is_pending_clear == false and global_update_exists[3] == true then -- Avoid id duplicates in _pending_update_clear
			table.insert(self._pending_update_clear, update_id)
		end
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- EXPOSED TO "update_handler" DURING ProfileStore:GlobalUpdateProfileAsync() CALL
function GlobalUpdates:AddActiveUpdate(update_data)
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't add active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't add active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local update_index = updates_latest[1] + 1 -- Incrementing global update index
	updates_latest[1] = update_index
	-- Add new active global update:
	table.insert(updates_latest[2], {update_index, 1, false, update_data})
end

function GlobalUpdates:ChangeActiveUpdate(update_id, update_data)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id")
	end
	if type(update_data) ~= "table" then
		error("[ProfileService]: Invalid update_data")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't change active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't change active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update = nil
	for _, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't change locked global update")
		end
		get_global_update[2] = get_global_update[2] + 1 -- Increment version id
		get_global_update[4] = update_data -- Set new global update data
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

function GlobalUpdates:ClearActiveUpdate(update_id)
	if type(update_id) ~= "number" then
		error("[ProfileService]: Invalid update_id argument")
	end
	if self._new_active_update_listeners ~= nil then
		error("[ProfileService]: Can't clear active global updates in loaded Profile; Use ProfileStore:GlobalUpdateProfileAsync()")
	elseif self._update_handler_mode ~= true then
		error("[ProfileService]: Can't clear active global updates in view mode; Use ProfileStore:GlobalUpdateProfileAsync()")
	end
	-- self._updates_latest = {}, -- [table] {update_index, {{update_id, version_id, update_locked, update_data}, ...}}
	local updates_latest = self._updates_latest
	local get_global_update_index = nil
	local get_global_update = nil
	for index, global_update in ipairs(updates_latest[2]) do
		if update_id == global_update[1] then
			get_global_update_index = index
			get_global_update = global_update
			break
		end
	end
	if get_global_update ~= nil then
		if get_global_update[3] == true then
			error("[ProfileService]: Can't clear locked global update")
		end
		table.remove(updates_latest[2], get_global_update_index) -- Remove active global update
	else
		error("[ProfileService]: Passed non-existant update_id")
	end
end

-- Profile object:

local Profile = {
	--[[
		Data = {}, -- [table] -- Loaded once after ProfileStore:LoadProfileAsync() finishes
		MetaData = {}, -- [table] -- Updated with every auto-save
		GlobalUpdates = GlobalUpdates, -- [GlobalUpdates]
		
		_profile_store = ProfileStore, -- [ProfileStore]
		_profile_key = "", -- [string]
		
		_release_listeners = {listener, ...} / nil, -- [table / nil]
		
		_view_mode = true / nil, -- [bool / nil]
		
		_load_timestamp = tick(),
		
		_is_user_mock = false, -- ProfileStore.Mock
	--]]
}
Profile.__index = Profile

function Profile:IsActive() --> [bool]
	local loaded_profiles = self._is_user_mock == true and self._profile_store._mock_loaded_profiles or self._profile_store._loaded_profiles
	return loaded_profiles[self._profile_key] == self
end

function Profile:GetMetaTag(tag_name) --> value
	local meta_data = self.MetaData
	if meta_data == nil then
		return nil
		-- error("[ProfileService]: This Profile hasn't been loaded before - MetaData not available")
	end
	return self.MetaData.MetaTags[tag_name]
end

function Profile:SetMetaTag(tag_name, value)
	if type(tag_name) ~= "string" then
		error("[ProfileService]: tag_name must be a string")
	elseif string.len(tag_name) == 0 then
		error("[ProfileService]: Invalid tag_name")
	end
	if self._view_mode == true then
		error("[ProfileService]: Can't set meta tag in view mode")
	end
	if self:IsActive() == false then
		error("[ProfileService]: PROFILE EXPIRED - Meta tags can't be set")
	end
	self.MetaData.MetaTags[tag_name] = value
end

function Profile:ListenToRelease(listener) --> [ScriptConnection] (place_id / nil, game_job_id / nil)
	if type(listener) ~= "function" then
		error("[ProfileService]: Only a function can be set as listener in Profile:ListenToRelease()")
	end
	if self._view_mode == true then
		error("[ProfileService]: Can't listen to Profile release in view mode")
	end
	if self:IsActive() == false then
		-- Call release listener immediately if profile is expired
		local place_id
		local game_job_id
		local active_session = self.MetaData.ActiveSession
		if active_session ~= nil then
			place_id = active_session[1]
			game_job_id = active_session[2]
		end
		listener(place_id, game_job_id)
		return {
			Disconnect = function() end,
		}
	else
		table.insert(self._release_listeners, listener)
		return Madwork.NewScriptConnection(self._release_listeners, listener)
	end
end

function Profile:Save()
	if self._view_mode == true then
		error("[ProfileService]: Can't save Profile in view mode")
	end
	if self:IsActive() == false then
		error("[ProfileService]: PROFILE EXPIRED - Can't save Profile")
	end
	-- We don't want auto save to trigger too soon after manual saving - this will reset the auto save timer:
	RemoveProfileFromAutoSave(self)
	AddProfileToAutoSave(self)
	-- Call save function in a new thread:
	coroutine.wrap(SaveProfileAsync)(self)
end

function Profile:Release()
	if self._view_mode == true then
		error("[ProfileService]: Can't release Profile in view mode")
	end
	if self:IsActive() == true then
		coroutine.wrap(SaveProfileAsync)(self, true) -- Call save function in a new thread with release_from_session = true
	end
end

-- ProfileStore object:

local ProfileStore = {
	--[[
		Mock = {},
	
		_profile_store_name = "", -- [string] -- DataStore name
		_profile_template = {} / nil, -- [table / nil]
		_global_data_store = global_data_store, -- [GlobalDataStore] -- Object returned by DataStoreService:GetDataStore(_profile_store_name)
		
		_loaded_profiles = {[profile_key] = Profile, ...},
		_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
		
		_mock_loaded_profiles = {[profile_key] = Profile, ...},
		_mock_profile_load_jobs = {[profile_key] = {load_id, loaded_data}, ...},
	--]]
}
ProfileStore.__index = ProfileStore

function ProfileStore:LoadProfileAsync(profile_key, not_released_handler, _use_mock) --> [Profile / nil] not_released_handler(place_id, game_job_id)
	if self._profile_template == nil then
		error("[ProfileService]: Profile template not set - ProfileStore:LoadProfileAsync() locked for this ProfileStore")
	end
	if type(profile_key) ~= "string" then
		error("[ProfileService]: profile_key must be a string")
	elseif string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(not_released_handler) ~= "function" and not_released_handler ~= "ForceLoad" and not_released_handler ~= "Steal" then
		error("[ProfileService]: Invalid not_released_handler")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
	end
	
	local is_user_mock = _use_mock == UseMockTag
	
	-- Check if profile with profile_key isn't already loaded in this session:
	for _, profile_store in ipairs(ActiveProfileStores) do
		if profile_store._profile_store_name == self._profile_store_name then
			local loaded_profiles = is_user_mock == true and profile_store._mock_loaded_profiles or profile_store._loaded_profiles
			if loaded_profiles[profile_key] ~= nil then
				error("[ProfileService]: Profile of ProfileStore \"" .. self._profile_store_name .. "\" with key \"" .. profile_key .. "\" is already loaded in this session")
				-- Are you using Profile:Release() properly?
			end
		end
	end
	
	ActiveProfileLoadJobs = ActiveProfileLoadJobs + 1
	local force_load = not_released_handler == "ForceLoad"
	local force_load_steps = 0
	local request_force_load = force_load -- First step of ForceLoad
	local steal_session = false -- Second step of ForceLoad
	local aggressive_steal = not_released_handler == "Steal" -- Developer invoked steal
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		-- SPECIAL CASE - If LoadProfileAsync is called for the same key before another LoadProfileAsync finishes,
		-- yoink the DataStore return for the new call. The older call will return nil. This would prevent very rare
		-- game breaking errors where a player rejoins the server super fast.
		local profile_load_jobs = is_user_mock == true and self._mock_profile_load_jobs or self._profile_load_jobs
		local loaded_data
		local load_id = LoadIndex + 1
		LoadIndex = load_id
		local profile_load_job = profile_load_jobs[profile_key] -- {load_id, loaded_data}
		if profile_load_job ~= nil then
			profile_load_job[1] = load_id -- Yoink load job
			while profile_load_job[2] == nil do -- Wait for job to finish
				Madwork.HeartbeatWait()
			end
			if profile_load_job[1] == load_id then -- Load job hasn't been double-yoinked
				loaded_data = profile_load_job[2]
				profile_load_jobs[profile_key] = nil
			else
				return nil
			end
		else
			profile_load_job = {load_id, nil}
			profile_load_jobs[profile_key] = profile_load_job
			profile_load_job[2] = StandardProfileUpdateAsyncDataStore(
				self,
				profile_key,
				{
					ExistingProfileHandle = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							local force_load_session = latest_data.MetaData.ForceLoadSession
							-- IsThisSession(active_session)
							if active_session == nil then
								latest_data.MetaData.ActiveSession = {PlaceId, JobId}
								latest_data.MetaData.ForceLoadSession = nil
							elseif type(active_session) == "table" then
								if IsThisSession(active_session) == false then
									local last_update = latest_data.MetaData.LastUpdate
									if last_update ~= nil then
										if os.time() - last_update > SETTINGS.AssumeDeadSessionLock then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
											return
										end
									end
									if steal_session == true or aggressive_steal == true then
										local force_load_uninterrupted = false
										if force_load_session ~= nil then
											force_load_uninterrupted = IsThisSession(force_load_session)
										end
										if force_load_uninterrupted == true or aggressive_steal == true then
											latest_data.MetaData.ActiveSession = {PlaceId, JobId}
											latest_data.MetaData.ForceLoadSession = nil
										end
									elseif request_force_load == true then
										latest_data.MetaData.ForceLoadSession = {PlaceId, JobId}
									end
								else
									latest_data.MetaData.ForceLoadSession = nil
								end
							end
						end
					end,
					MissingProfileHandle = function(latest_data)
						latest_data.Data = DeepCopyTable(self._profile_template)
						latest_data.MetaData = {
							ProfileCreateTime = os.time(),
							SessionLoadCount = 0,
							ActiveSession = {PlaceId, JobId},
							ForceLoadSession = nil,
							MetaTags = {},
							
						}
					end,
					EditProfile = function(latest_data)
						if ProfileService.ServiceLocked == false then
							local active_session = latest_data.MetaData.ActiveSession
							if active_session ~= nil and IsThisSession(active_session) == true then
								latest_data.MetaData.SessionLoadCount = latest_data.MetaData.SessionLoadCount + 1
								latest_data.MetaData.LastUpdate = os.time()
							end
						end
					end,
				},
				is_user_mock
			)
			if profile_load_job[1] == load_id then -- Load job hasn't been yoinked
				loaded_data = profile_load_job[2]
				profile_load_jobs[profile_key] = nil
			else
				return nil -- Load job yoinked
			end
		end
		-- Handle load_data:
		if loaded_data ~= nil then
			local active_session = loaded_data.MetaData.ActiveSession
			if type(active_session) == "table" then
				if IsThisSession(active_session) == true then
					-- Special component in MetaTags:
					loaded_data.MetaData.MetaTagsLatest = DeepCopyTable(loaded_data.MetaData.MetaTags)
					-- Case #1: Profile is now taken by this session:
					-- Create Profile object:
					local global_updates_object = {
						_updates_latest = loaded_data.GlobalUpdates,
						_pending_update_lock = {},
						_pending_update_clear = {},
						
						_new_active_update_listeners = {},
						_new_locked_update_listeners = {},
						
						_profile = nil,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					local profile = {
						Data = loaded_data.Data,
						MetaData = loaded_data.MetaData,
						GlobalUpdates = global_updates_object,
						
						_profile_store = self,
						_profile_key = profile_key,
						
						_release_listeners = {},
						
						_load_timestamp = tick(),
						
						_is_user_mock = is_user_mock,
					}
					setmetatable(profile, Profile)
					global_updates_object._profile = profile
					-- Referencing Profile object in ProfileStore:
					if next(self._loaded_profiles) == nil and next(self._mock_loaded_profiles) == nil then -- ProfileStore object was inactive
						table.insert(ActiveProfileStores, self)
					end
					if is_user_mock == true then
						self._mock_loaded_profiles[profile_key] = profile
					else
						self._loaded_profiles[profile_key] = profile
					end
					-- Adding profile to AutoSaveList;
					AddProfileToAutoSave(profile)
					-- Special case - finished loading profile, but session is shutting down:
					if ProfileService.ServiceLocked == true then
						SaveProfileAsync(profile, true) -- Release profile and yield until the DataStore call is finished
						profile = nil -- nil will be returned by this call
					end
					-- Return Profile object:
					ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
					return profile
				else
					-- Case #2: Profile is taken by some other session:
					if force_load == true then
						local force_load_session = loaded_data.MetaData.ForceLoadSession
						local force_load_uninterrupted = false
						if force_load_session ~= nil then
							force_load_uninterrupted = IsThisSession(force_load_session)
						end
						if force_load_uninterrupted == true then
							if request_force_load == false then
								force_load_steps = force_load_steps + 1
								if force_load_steps == SETTINGS.ForceLoadMaxSteps then
									steal_session = true
								end
							end
							Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						else
							-- Another session tried to force load this profile:
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						end
						request_force_load = false -- Only request a force load once
					elseif aggressive_steal == true then
						Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
					else
						local handler_result = not_released_handler(active_session[1], active_session[2])
						if handler_result == "Repeat" then
							Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						elseif handler_result == "Cancel" then
							ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
							return nil
						elseif handler_result == "ForceLoad" then
							force_load = true
							request_force_load = true
							Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						elseif handler_result == "Steal" then
							aggressive_steal = true
							Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
						else
							error("[ProfileService]: Invalid return from not_released_handler")
						end
					end
				end
			else
				ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
				error("[ProfileService]: Invalid ActiveSession value in Profile.MetaData - Fatal corruption") -- It's unlikely this will ever fire
			end
		else
			Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
		end
	end
	ActiveProfileLoadJobs = ActiveProfileLoadJobs - 1
	return nil -- If loop breaks return nothing
end

function ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler, _use_mock) --> [GlobalUpdates / nil] (update_handler(GlobalUpdates))
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	if type(update_handler) ~= "function" then
		error("[ProfileService]: Invalid update_handler")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
	end
	
	while ProfileService.ServiceLocked == false do
		-- Updating profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = function(latest_data)
					-- Running update_handler:
					local global_updates_object = {
						_updates_latest = latest_data.GlobalUpdates,
						_update_handler_mode = true,
					}
					setmetatable(global_updates_object, GlobalUpdates)
					update_handler(global_updates_object)
				end,
			},
			_use_mock == UseMockTag
		)
		-- Handling loaded_data:
		if loaded_data ~= nil then
			-- Return GlobalUpdates object (Update successful):
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			return global_updates_object
		else
			Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again
		end
	end
	return nil -- Return nothing (Update unsuccessful)
end
		
function ProfileStore:ViewProfileAsync(profile_key, _use_mock) --> [Profile / nil]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	
	if ProfileService.ServiceLocked == true then
		return nil
	end
	
	while ProfileService.ServiceLocked == false do
		-- Load profile:
		local loaded_data = StandardProfileUpdateAsyncDataStore(
			self,
			profile_key,
			{
				ExistingProfileHandle = nil,
				MissingProfileHandle = nil,
				EditProfile = nil,
			},
			_use_mock == UseMockTag
		)
		-- Handle load_data:
		if loaded_data ~= nil then
			-- Create Profile object:
			local global_updates_object = {
				_updates_latest = loaded_data.GlobalUpdates,
				_profile = nil,
			}
			setmetatable(global_updates_object, GlobalUpdates)
			local profile = {
				Data = loaded_data.Data,
				MetaData = loaded_data.MetaData,
				GlobalUpdates = global_updates_object,
				
				_profile_store = self,
				_profile_key = profile_key,
				
				_view_mode = true,
				
				_load_timestamp = tick(),
			}
			setmetatable(profile, Profile)
			global_updates_object._profile = profile
			-- Returning Profile object:
			return profile
		else
			Madwork.HeartbeatWait(SETTINGS.LoadProfileRepeatDelay) -- Let the cycle repeat again after a delay
		end
	end
	return nil -- If loop breaks return nothing
end

function ProfileStore:WipeProfileAsync(profile_key, _use_mock) --> is_wipe_successful [bool]
	if type(profile_key) ~= "string" or string.len(profile_key) == 0 then
		error("[ProfileService]: Invalid profile_key")
	end
	
	if ProfileService.ServiceLocked == true then
		return false
	end
	
	return StandardProfileUpdateAsyncDataStore(
		self,
		profile_key,
		{
			WipeProfile = true
		},
		_use_mock == UseMockTag
	)
end

-- New ProfileStore:

function ProfileService.GetProfileStore(profile_store_name, profile_template) --> [ProfileStore]
	if type(profile_store_name) ~= "string" then
		error("[ProfileService]: profile_store_name must be a string")
	elseif string.len(profile_store_name) == 0 then
		error("[ProfileService]: Invalid profile_store_name")
	end
	
	if type(profile_template) ~= "table" then
		error("[ProfileService]: Invalid profile_template")
	end
	
	local profile_store
	profile_store = {
		Mock = {
			LoadProfileAsync = function(_, profile_key, not_released_handler)
				return profile_store:LoadProfileAsync(profile_key, not_released_handler, UseMockTag)
			end,
			GlobalUpdateProfileAsync = function(_, profile_key, update_handler)
				return profile_store:GlobalUpdateProfileAsync(profile_key, update_handler, UseMockTag)
			end,
			ViewProfileAsync = function(_, profile_key)
				return profile_store:ViewProfileAsync(profile_key, UseMockTag)
			end,
			WipeProfileAsync = function(_, profile_key)
				return profile_store:WipeProfileAsync(profile_key, UseMockTag)
			end
		},
		
		_profile_store_name = profile_store_name,
		_profile_template = profile_template,
		_global_data_store = nil,
		_loaded_profiles = {},
		_profile_load_jobs = {},
		_mock_loaded_profiles = {},
		_mock_profile_load_jobs = {},
	}
	if UseMockDataStore == false then
		profile_store._global_data_store = DataStoreService:GetDataStore(profile_store_name)
	end
	setmetatable(profile_store, ProfileStore)
	return profile_store
end

----- Initialize -----

if IsStudio == true then
	local status, message = pcall(function()
		-- This will error if current instance has no Studio API access:
		DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
	end)
	if status == false and (string.find(message, "403", 1, true) ~= nil or string.find(message, "must publish", 1, true) ~= nil) then
		UseMockDataStore = true
		ProfileService._use_mock_data_store = true
		print("[ProfileService]: Roblox API services unavailable - data will not be saved")
	else
		print("[ProfileService]: Roblox API services available - data will be saved")
	end
end

----- Connections -----

-- Auto saving and issue queue managing:
RunService.Heartbeat:Connect(function()
	-- 1) Auto saving: --
	local auto_save_list_length = #AutoSaveList
	if auto_save_list_length > 0 then
		local auto_save_index_speed = SETTINGS.AutoSaveProfiles / auto_save_list_length
		local current_tick = tick()
		while current_tick - LastAutoSave > auto_save_index_speed do
			LastAutoSave = LastAutoSave + auto_save_index_speed
			local profile = AutoSaveList[AutoSaveIndex]
			if current_tick - profile._load_timestamp &lt; SETTINGS.AutoSaveProfiles then
				-- This profile is freshly loaded - auto-saving immediately after loading will cause a warning in the log:
				profile = nil
				for _ = 1, auto_save_list_length - 1 do
					-- Move auto save index to the right:
					AutoSaveIndex = AutoSaveIndex + 1
					if AutoSaveIndex > auto_save_list_length then
						AutoSaveIndex = 1
					end
					profile = AutoSaveList[AutoSaveIndex]
					if current_tick - profile._load_timestamp >= SETTINGS.AutoSaveProfiles then
						break
					else
						profile = nil
					end
				end
			end
			-- Move auto save index to the right:
			AutoSaveIndex = AutoSaveIndex + 1
			if AutoSaveIndex > auto_save_list_length then
				AutoSaveIndex = 1
			end
			-- Perform save call:
			-- print("[ProfileService]: Auto updating profile - profile_store_name = \"" .. profile._profile_store._profile_store_name .. "\"; profile_key = \"" .. profile._profile_key .. "\"")
			if profile ~= nil then
				coroutine.wrap(SaveProfileAsync)(profile) -- Auto save profile in new thread
			end
		end
	end
	-- 2) Issue queue: --
	-- Critical state handling:
	if ProfileService.CriticalState == false then
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			ProfileService.CriticalState = true
			ProfileService.CriticalStateSignal:Fire(true)
			CriticalStateStart = tick()
			warn("[ProfileService]: Entered critical state")
		end
	else
		if #IssueQueue >= SETTINGS.IssueCountForCriticalState then
			CriticalStateStart = tick()
		elseif tick() - CriticalStateStart > SETTINGS.CriticalStateLast then
			ProfileService.CriticalState = false
			ProfileService.CriticalStateSignal:Fire(false)
			warn("[ProfileService]: Critical state ended")
		end
	end
	-- Issue queue:
	while true do
		local issue_tick = IssueQueue[1]
		if issue_tick == nil then
			break
		elseif tick() - issue_tick > SETTINGS.IssueLast then
			table.remove(IssueQueue, 1)
		else
			break
		end
	end
end)

-- Release all loaded profiles when the server is shutting down:
Madwork.ConnectToOnClose(
	function()
		ProfileService.ServiceLocked = true
		-- 1) Release all active profiles: --
		-- Clone AutoSaveList to a new table because AutoSaveList changes when profiles are released:
		local on_close_save_job_count = 0
		local active_profiles = {}
		for index, profile in ipairs(AutoSaveList) do
			active_profiles[index] = profile
		end
		-- Release the profiles; Releasing profiles can trigger listeners that release other profiles, so check active state:
		for _, profile in ipairs(active_profiles) do
			if profile:IsActive() == true then
				on_close_save_job_count = on_close_save_job_count + 1
				coroutine.wrap(function() -- Save profile on new thread
					SaveProfileAsync(profile, true)
					on_close_save_job_count = on_close_save_job_count - 1
				end)()
			end
		end
		-- 2) Yield until all active profile jobs are finished: --
		while on_close_save_job_count > 0 or ActiveProfileLoadJobs > 0 or ActiveProfileSaveJobs > 0 do
			Madwork.HeartbeatWait()
		end
		return -- We're done!
	end,
	UseMockDataStore == false -- Always run this OnClose task if using Roblox API services
)

return ProfileService</string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="29">
        <Properties>
          <string name="Name">Services</string>
        </Properties>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">EchoService</string>
            <string name="Source">-- Echo Service
-- Username
-- September 6, 2020



local EchoService = {Client = {}}


function EchoService:Start()
    print("Echo Server Start")
	
end


function EchoService:Init()
	
end


return EchoService</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="31">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="32">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="33">
        <Properties>
          <string name="Name">Aero</string>
        </Properties>
        <Item class="Folder" referent="34">
          <Properties>
            <string name="Name">Controllers</string>
          </Properties>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">EchoController</string>
              <string name="Source">-- Echo Controller
-- Username
-- September 6, 2020



local EchoController = {}


function EchoController:Start()
    print("Echo Controller Hello World")
	
end


function EchoController:Init()
	
end


return EchoController</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="36">
            <Properties>
              <string name="Name">Fade</string>
              <string name="Source"><![CDATA[-- Fade
-- Stephen Leitnick
-- February 4, 2017

--[[
	
	
	METHODS:
	
		Fade:In([duration [, async] ])                  Fade in from black
		Fade:Out([duration [, async] ])                 Fade out to black
		
		Fade:To(transparency [, duration [, async] ])   Fade to the given transparency level
		Fade:FromTo(from, to [, duration [, async] ])   Fade from one transparency level to another
		
		Fade:SetText(text)                              Set text to show on fade screen
		Fade:ClearText()                                Sets text to a blank string
		Fade:SetTextSize(size)				Sets the text size (0 for auto scaling)
		Fade:SetFont(font)                              Sets the font
		
		Fade:SetBackgroundColor(color)                  Set the fade color (can be a Color3 or BrickColor)
		Fade:SetTextColor(color)                        Set the text color (can be a Color3 or BrickColor)
		
		Fade:SetEasingStyle(easingStyle)                Set the easing style (e.g. Enum.EasingStyle.Quad)
		
		Fade:GetScreenGui()                             Returns the ScreenGui for this fade system
		Fade:GetFrame()                                 Returns the overlay Frame
		Fade:GetLabel()                                 Returns the TextLabel used for showing text
	
	
	EVENTS:
		
		Fade.Started()
		Fade.Ended()
	
	
	
	EXAMPLES:
		
		-- Hello fade:
		Fade:SetText("Hello")
		Fade:Out()
		wait(1)
		Fade:In()
		
		-- Slow fade:
		Fade:ClearText()
		Fade:Out(5)
		wait(1)
		Fade:In(5)
		
		-- Half fade:
		Fade:To(0.5)
		
		-- Asynchronous w/ events:
		Fade.Ended:connect(function()
			print("Fade ended!")
		end)
		Fade:Out(1, true)
	
	
	
	
	Note: This module is dependent on the Tween module.
	
--]]



local Fade = {}


local DEFAULT_DURATION = 0.5
local DEFAULT_ASYNC    = false


-- ScreenGui:
local fadeGui = Instance.new("ScreenGui")
	fadeGui.Name = "FadeGui"
	fadeGui.DisplayOrder = 9
	fadeGui.ResetOnSpawn = false
	fadeGui.IgnoreGuiInset = true -- Now ignores the inset because what kind of monster would want this off?

-- Main overlay frame:
local fade = Instance.new("Frame")
	fade.Name = "Fade"
	fade.Size = UDim2.new(1, 0, 1, 0)
	fade.Position = UDim2.new(0, 0, 0, 0)
	fade.BorderSizePixel = 0
	fade.BackgroundColor3 = Color3.new(0, 0, 0)
	fade.BackgroundTransparency = 1
	fade.Parent = fadeGui

-- Text label:
local label = Instance.new("TextLabel")
	label.Name = "Label"
	label.AnchorPoint = Vector2.new(0.5, 0.5)
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.SourceSans
	label.TextScaled = true
	label.TextWrapped = true
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Position = UDim2.new(0.5, 0, 0.5, 0)
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Text = ""
	label.Parent = fade


local easingStyle = Enum.EasingStyle.Quad

local Tween
local currentTween

--local fadeStarted
--local fadeEnded

local fadeStartedEvent = "Started"
local fadeEndedEvent = "Ended"


-- Set background color:
function Fade:SetBackgroundColor(c)
	local t = typeof(c)
	if (t == "Color3") then
		fade.BackgroundColor3 = c
	elseif (t == "BrickColor") then
		fade.BackgroundColor3 = c.Color
	else
		error("Argument must be of type Color3 or BrickColor")
	end
end


-- Set text color:
function Fade:SetTextColor(c)
	local t = typeof(c)
	if (t == "Color3") then
		label.TextColor3 = c
	elseif (t == "BrickColor") then
		label.TextColor3 = c.Color
	else
		error("Argument must be of type Color3 or BrickColor")
	end
end


-- Set text:
function Fade:SetText(text)
	label.Text = (text == nil and "" or tostring(text))
end


-- Set text size:
function Fade:SetTextSize(size)
	-- Turn off text wrapping no matter what because if we turn on text scaling, wrapping will automatically turn back on
	label.TextWrapped = false
	label.TextScaled = (size == 0 and true or false)
	label.TextSize = (size == 0 and label.TextSize or size) -- Don't bother changing text size if we turn on auto scaling
end


-- Set font:
function Fade:SetFont(font)
	label.Font = font
end


-- Clear text:
function Fade:ClearText()
	self:SetText(nil)
end


-- Fade in (fade the transparency frame out of the picture)
function Fade:In(duration, async)
	self:FromTo(0, 1, duration, async)
end


--  Fade out (fade the transparency frame into picture)
function Fade:Out(duration, async)
	self:FromTo(1, 0, duration, async)
end


-- Fade to a transparency, starting at whatever transparency level it is currently:
function Fade:To(transparency, duration, async)
	self:FromTo(fade.BackgroundTransparency, transparency, duration, async)
end


-- Fade from a transparency to another:
function Fade:FromTo(fromTransparency, toTransparency, duration, async)
	
	assert(type(fromTransparency) == "number", "'fromTransparency' argument must be a number")
	assert(type(toTransparency) == "number", "'toTransparency' argument must be a number")
	assert(duration == nil or type(duration) == "number", "'duration' argument must be a number or nil")
	
	duration = (duration or DEFAULT_DURATION)
	
	if (duration <= 0) then
		-- Instant fade; skip everything else:
		self:FireEvent(fadeStartedEvent)
		fade.BackgroundTransparency = toTransparency
		label.TextTransparency = toTransparency
		self:FireEvent(fadeEndedEvent)
		return
	end
	
	if (async == nil) then
		async = DEFAULT_ASYNC
	end
	
	-- If already fading, stop fading so we can prioritize this new fade:
	if (currentTween) then
		currentTween:Cancel()
		currentTween = nil
	end
	
	-- Fire Started event:
	self:FireEvent(fadeStartedEvent)
	
	local deltaTransparency = (toTransparency - fromTransparency)
	
	-- Fade operation:
	local tweenInfo = TweenInfo.new(
		(duration or DEFAULT_DURATION),
		easingStyle,
		(fromTransparency > toTransparency and Enum.EasingDirection.In or Enum.EasingDirection.Out)
	)
	currentTween = Tween.new(tweenInfo, function(ratio)
		local transparency = (fromTransparency + (deltaTransparency * ratio))
		fade.BackgroundTransparency = transparency
		label.TextTransparency = transparency
	end)
	
	-- Start fading:
	currentTween:Play()
	
	-- Await fade to end, then fire Ended event:
	local function AwaitEnd()
		currentTween.Completed:Wait()
		self:FireEvent(fadeEndedEvent)
	end
	
	if (async) then
		coroutine.wrap(AwaitEnd)()
	else
		AwaitEnd()
	end
	
end


function Fade:SetEasingStyle(style)
	assert(typeof(style) == "EnumItem", "Argument must be of type EnumItem")
	easingStyle = style
end


function Fade:GetScreenGui()
	return fadeGui
end


function Fade:GetFrame()
	return fade
end


function Fade:GetLabel()
	return label
end


function Fade:Start()
	fadeGui.Parent = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
end


function Fade:Init()
	Tween = self.Modules.Tween
	self:RegisterEvent(fadeStartedEvent)
	self:RegisterEvent(fadeEndedEvent)
end


return Fade
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">TaskScheduler</string>
              <string name="Source">-- Author: EchoReaper
-- Roblox Link: https://www.roblox.com/Task-Scheduler-item?id=348019935
-- Publically released January 25, 2016

-- Changes made from EchoReaper's version:
	-- GetCurrentFPS() method removed
	-- FPS is only tracked when the 'Loop' function is running for performance reasons
	-- Styled code in consistency with the rest of the AeroGameFramework codebase

--[[
	
	local scheduler = TaskScheduler:CreateScheduler(targetedMinimumFPS)
	
	scheduler:QueueTask(function)
	scheduler:Pause()
	scheduler:Resume()
	scheduler:Destroy()
	
--]]




local TaskScheduler = {}

local lastIteration
local frameUpdateTable = {}

local runService = game:GetService("RunService")

--[[
	param targetFps  Task scheduler won't run a task if it'd make the FPS drop below this amount
					 (WARNING) this only holds true if it is used properly. If you try to complete 10 union operations
					 at once in a single task then of course your FPS is going to drop -- queue the union operations
					 up one at a time so the task scheduler can do its job.
					
					
	returns scheduler
		method Pause      Pauses the scheduler so it won't run tasks. Tasks may still be added while the scheduler is
						  paused. They just won't be touched until it's resumed. Performance efficient -- disables
						  execution loop entirely until scheduler is resumed.
		
		method Resume     Resumes the paused scheduler.
		
		method Destroy    Destroys the scheduler so it can't be used anymore.
		
		method QueueTask  Queues a task for automatic execution.
			param callback  function (task) to be run.
	
	Example usage:
	
	local scheduler = TaskScheduler:CreateScheduler(60)
	local totalOperations = 0
	local paused
	for i=1,100 do
		scheduler:QueueTask(function()
			local partA = Instance.new("Part", workspace)
			local partB = Instance.new("Part", workspace)
			plugin:Union({partA, partB}):Destroy()
			totalOperations = totalOperations + 1
			print("Times unioned:", totalOperations)
			if (totalOperations == 50) then
				scheduler:Pause()
				paused = true
			end
		end)
	end
	
	repeat wait() until paused
	wait(2)
	scheduler:Resume()
--]]


function TaskScheduler:CreateScheduler(targetFps)
	
	local scheduler = {}
	local queue = {}
	local sleeping = true
	local paused
	
	local updateFrameTableEvent = nil
	
	local start = tick()
	runService.RenderStepped:Wait()
	
	local function UpdateFrameTable()
		lastIteration = tick()
		for i = #frameUpdateTable,1,-1 do
			frameUpdateTable[i + 1] = ((frameUpdateTable[i] >= (lastIteration - 1)) and frameUpdateTable[i] or nil)
		end
		frameUpdateTable[1] = lastIteration
	end

	local function Loop()
		updateFrameTableEvent = runService.RenderStepped:Connect(UpdateFrameTable)
		while (true) do
			if (sleeping) then break end
			local fps = (((tick() - start) >= 1 and #frameUpdateTable) or (#frameUpdateTable / (tick() - start)))
			if (fps >= targetFps and (tick() - frameUpdateTable[1]) &lt; (1 / targetFps)) then
				if (#queue > 0) then
					queue[1]()
					table.remove(queue, 1)
				else
					sleeping = true
					break
				end
			else
				runService.RenderStepped:Wait()
			end
		end
		updateFrameTableEvent:Disconnect()
		updateFrameTableEvent = nil
	end

	function scheduler.Pause(_s)
		paused = true
		sleeping = true
	end
	
	function scheduler.Resume(_s)
		if (paused) then
			paused = false
			sleeping = false
			Loop()
		end
	end
	
	function scheduler.Destroy(_s)
		scheduler:Pause()
		for i in pairs(scheduler) do
			scheduler[i] = nil
		end
		setmetatable(scheduler, {
			__index = function()
				error("Attempt to use destroyed scheduler")
			end;
			__newindex = function()
				error("Attempt to use destroyed scheduler")
			end;
		})
	end
	
	function scheduler.QueueTask(_s, callback)
		queue[#queue + 1] = callback
		if (sleeping and not paused) then
			sleeping = false
			Loop()
		end
	end
	
	return scheduler
	
end


return TaskScheduler</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="38">
            <Properties>
              <string name="Name">UserInput</string>
              <string name="Source"><![CDATA[-- User Input
-- Stephen Leitnick
-- January 2, 2018

--[[
	
	UserInput simply encapsulates all user input modules.
	
	UserInput.Preferred
		- Keyboard
		- Mouse
		- Gamepad
		- Touch
	
	UserInput:Get(inputModuleName)
	UserInput:GetPreferred()

	UserInput.PreferredChanged(preferred)
	
	
	Example:
	
	local keyboard = userInput:Get("Keyboard")
	keyboard.KeyDown:Connect(function(key) end)
	
--]]



local UserInput = {}

UserInput.HideMouse = false

UserInput.Preferred = {
	Keyboard = 0;
	Mouse = 1;
	Gamepad = 2;
	Touch = 3;
}
UserInput._preferred = nil

local modules = {}
local userInput = game:GetService("UserInputService")


function UserInput:Get(moduleName)
	return modules[moduleName]
end


function UserInput:Init()

	for _,obj in ipairs(script:GetChildren()) do
		if (obj:IsA("ModuleScript")) then
			local module = require(obj)
			self:WrapModule(module)
			modules[obj.Name] = module
		end
	end
	
	local function SetMouseIconEnabled(enabled)
		if (self.HideMouse) then
			userInput.MouseIconEnabled = enabled
		end
	end

	local function ChangePreferred(newPreferred)
		if (self._preferred ~= newPreferred) then
			self._preferred = newPreferred
			self.PreferredChanged:Fire(newPreferred)
			if (newPreferred == self.Preferred.Mouse or newPreferred == self.Preferred.Keyboard) then
				SetMouseIconEnabled(true)
			else
				SetMouseIconEnabled(false)
			end
		end
	end

	local function LastInputTypeChanged(lastInputType)
		if (lastInputType.Name:match("^Mouse")) then
			ChangePreferred(self.Preferred.Mouse)
		elseif (lastInputType == Enum.UserInputType.Keyboard or lastInputType == Enum.UserInputType.TextInput) then
			ChangePreferred(self.Preferred.Keyboard)
		elseif (lastInputType.Name:match("^Gamepad")) then
			ChangePreferred(self.Preferred.Gamepad)
		elseif (lastInputType == Enum.UserInputType.Touch) then
			ChangePreferred(self.Preferred.Touch)
		end
	end

	userInput.LastInputTypeChanged:Connect(LastInputTypeChanged)
	self.PreferredChanged = self.Shared.Signal.new()

	if (game:GetService("GuiService"):IsTenFootInterface()) then
		ChangePreferred(self.Preferred.Gamepad)
	elseif (userInput.TouchEnabled) then
		ChangePreferred(self.Preferred.Touch)
	else
		ChangePreferred(self.Preferred.Keyboard)
	end

end


function UserInput:GetPreferred()
	return self._preferred
end


return UserInput
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="39">
              <Properties>
                <string name="Name">Gamepad</string>
                <string name="Source"><![CDATA[-- Gamepad
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	gamepad = Gamepad.new(gamepadUserInputType)
	
	Boolean      gamepad:IsDown(keyCode)
	Boolean      gamepad:IsConnected()
	InputObject  gamepad:GetState(keyCode)
	Void         gamepad:SetMotor(motor, value)
	Void         gamepad:StopMotor(motor)
	Void         gamepad:StopAllMotors()
	Boolean      gamepad:IsMotorSupported(motor)
	Boolean      gamepad:IsVibrationSupported()
	Float        gamepad:GetMotorValue(motor)
	Float        gamepad:ApplyDeadzone(value, deadzoneThreshold)
	
	gamepad.ButtonDown(keyCode)
	gamepad.ButtonUp(keyCode)
	gamepad.Changed(keyCode, input)
	gamepad.Connected()
	gamepad.Disconnected()
	
--]]



local Gamepad = {}
Gamepad.__index = Gamepad

local gamepadsByInputType = {}

local userInput = game:GetService("UserInputService")
local hapticService = game:GetService("HapticService")
local abs = math.abs

local InverseLerp


function Gamepad.new(gamepad)
	
	if (gamepadsByInputType[gamepad]) then
		return gamepadsByInputType[gamepad]
	end
	
	local self = setmetatable({
		_gamepadInput = gamepad;
		_state = {};
		_isConnected = false;
	}, Gamepad)
	
	self.ButtonDown   = self.Shared.Signal.new()
	self.ButtonUp     = self.Shared.Signal.new()
	self.Changed      = self.Shared.Signal.new()
	self.Connected    = self.Shared.Signal.new()
	self.Disconnected = self.Shared.Signal.new()
	
	self._listeners = self.Shared.ListenerList.new()
	
	if (userInput:GetGamepadConnected(gamepad)) then
		self._isConnected = true
		self:ConnectAll()
	end
	
	-- Connected:
	userInput.GamepadConnected:Connect(function(gamepadNum)
		if (gamepadNum == gamepad) then
			self._isConnected = true
			self:ConnectAll()
			self.Connected:Fire()
		end
	end)
	
	-- Disconnected:
	userInput.GamepadDisconnected:Connect(function(gamepadNum)
		if (gamepadNum == gamepad) then
			self._isConnected = false
			self:DisconnectAll()
			self.Disconnected:Fire()
		end
	end)
	
	-- Map InputObject states to corresponding KeyCodes:
	for _,input in ipairs(userInput:GetGamepadState(gamepad)) do
		self._state[input.KeyCode] = input
	end
	
	gamepadsByInputType[gamepad] = self
	
	return self
	
end


function Gamepad:ConnectAll()
	
	-- Input Began:
	self._listeners:Connect(userInput.InputBegan, function(input, processed)
		if (processed) then return end
		if (input.UserInputType == self._gamepadInput) then
			self.ButtonDown:Fire(input.KeyCode)
		end
	end)
	
	-- Input Ended:
	self._listeners:Connect(userInput.InputEnded, function(input, _processed)
		if (input.UserInputType == self._gamepadInput) then
			self.ButtonUp:Fire(input.KeyCode)
		end
	end)
	
	-- Input Changed:
	self._listeners:Connect(userInput.InputChanged, function(input, _processed)
		if (input.UserInputType == self._gamepadInput) then
			self.Changed:Fire(input.KeyCode, input)
		end
	end)
	
end


function Gamepad:DisconnectAll()
	self._listeners:DisconnectAll()
end


function Gamepad:IsDown(keyCode)
	return userInput:IsGamepadButtonDown(self._gamepadInput, keyCode)
end


function Gamepad:IsConnected()
	return self._isConnected
end


function Gamepad:GetState(keyCode)
	return self._state[keyCode]
end


function Gamepad:SetMotor(motor, value)
	hapticService:SetMotor(self._gamepadInput, motor, value)
end


function Gamepad:IsMotorSupported(motor)
	return hapticService:IsMotorSupported(self._gamepadInput, motor)
end


function Gamepad:IsVibrationSupported()
	return hapticService:IsVibrationSupported(self._gamepadInput)
end


function Gamepad:StopMotor(motor)
	self:SetMotor(motor, 0)
end


function Gamepad:GetMotorValue(motor)
	return hapticService:GetMotor(self._gamepadInput, motor)
end


function Gamepad:StopAllMotors()
	for _,motor in ipairs(Enum.VibrationMotor:GetEnumItems()) do
		self:StopMotor(motor)
	end
end


function Gamepad:ApplyDeadzone(value, deadzoneThreshold)
	if (abs(value) < deadzoneThreshold) then
		return 0
	else
		return InverseLerp(deadzoneThreshold, 1, abs(value)) * (value > 0 and 1 or -1)
	end
end


function Gamepad:Start()
	
end


function Gamepad:Init()
	InverseLerp = self.Shared.NumberUtil.InverseLerp
end


return Gamepad
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="40">
              <Properties>
                <string name="Name">Keyboard</string>
                <string name="Source">-- Keyboard
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	Boolean   Keyboard:IsDown(keyCode)
	Boolean   Keyboard:AreAllDown(keyCodes...)
	Boolean   Keyboard:AreAnyDown(keyCodes...)
	
	Keyboard.KeyDown(keyCode)
	Keyboard.KeyUp(keyCode)
	
--]]



local Keyboard = {}

local userInput = game:GetService("UserInputService")


function Keyboard:IsDown(keyCode)
	return userInput:IsKeyDown(keyCode)
end


function Keyboard:AreAllDown(...)
	for _,keyCode in pairs{...} do
		if (not userInput:IsKeyDown(keyCode)) then
			return false
		end
	end
	return true
end


function Keyboard:AreAnyDown(...)
	for _,keyCode in pairs{...} do
		if (userInput:IsKeyDown(keyCode)) then
			return true
		end
	end
	return false
end


function Keyboard:Start()
	
end


function Keyboard:Init()
	
	self.KeyDown = self.Shared.Signal.new()
	self.KeyUp = self.Shared.Signal.new()
	
	userInput.InputBegan:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.Keyboard) then
			self.KeyDown:Fire(input.KeyCode)
		end
	end)
	
	userInput.InputEnded:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.Keyboard) then
			self.KeyUp:Fire(input.KeyCode)
		end
	end)
	
end


return Keyboard</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="41">
              <Properties>
                <string name="Name">Mobile</string>
                <string name="Source"><![CDATA[-- Mobile
-- Stephen Leitnick
-- December 28, 2017

--[[

	Mobile:GetDeviceAcceleration()
	Mobile:GetDeviceGravity()
	Mobile:GetDeviceRotation()
	
	Mobile.TouchStarted(position)
	Mobile.TouchEnded(position)
	Mobile.TouchMoved(position, delta)
	Mobile.TouchTapInWorld(position)
	Mobile.TouchPinch(touchPositions, scale, velocity, state)
	Mobile.TouchLongPress(touchPositions, state)
	Mobile.TouchPan(touchPositions, totalTranslation, velocity, state)
	Mobile.TouchRotate(touchPositions, rotation, velocity, state)
	Mobile.TouchSwipe(swipeDirection, numberOfTouches)
	Mobile.TouchTap(touchPositions)
	Mobile.DeviceAccelerationChanged(acceleration)
	Mobile.DeviceGravityChanged(gravity)
	Mobile.DeviceRotationChanged(rotation, cframe)
	
--]]



local Mobile = {}

local RAY_DISTANCE = 1000

local workspace = workspace

local userInput = game:GetService("UserInputService")
local cam = workspace.CurrentCamera


function Mobile:GetRay(position)
	local viewportMouseRay = cam:ViewportPointToRay(position.X, position.Y)
	return Ray.new(viewportMouseRay.Origin, viewportMouseRay.Direction * RAY_DISTANCE)
end


function Mobile:Cast(position, ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
	warn("Mobile:Cast() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRay(self:GetRay(position), ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
end


function Mobile:CastWithIgnoreList(position, ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
	warn("Mobile:CastWithIgnoreList() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRayWithIgnoreList(self:GetRay(position), ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
end


function Mobile:CastWithWhitelist(position, whitelistDescendantsTable, ignoreWater)
	warn("Mobile:CastWithWhitelist() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRayWithWhitelist(self:GetRay(position), whitelistDescendantsTable, ignoreWater)
end


function Mobile:Raycast(raycastParams, distance)
	local mousePos = userInput:GetMouseLocation()
	local viewportMouseRay = cam:ViewportPointToRay(mousePos.X, mousePos.Y)
	return workspace:Raycast(viewportMouseRay.Origin, viewportMouseRay.Direction * (distance or RAY_DISTANCE), raycastParams)
end


function Mobile:Init()
	
	self.TouchStarted = self.Shared.Signal.new()
	self.TouchEnded = self.Shared.Signal.new()
	self.TouchMoved = self.Shared.Signal.new()
	self.TouchTapInWorld = self.Shared.Signal.new()
	self.TouchPinch = self.Shared.Signal.new()
	self.TouchLongPress = self.Shared.Signal.new()
	self.TouchPan = self.Shared.Signal.new()
	self.TouchRotate = self.Shared.Signal.new()
	self.TouchSwipe = self.Shared.Signal.new()
	self.TouchTap = self.Shared.Signal.new()
	
	userInput.TouchStarted:Connect(function(input, processed)
		if (processed) then return end
		self.TouchStarted:Fire(input.Position)
	end)
	
	userInput.TouchEnded:Connect(function(input, _processed)
		self.TouchEnded:Fire(input.Position)
	end)
	
	userInput.TouchMoved:Connect(function(input, processed)
		if (processed) then return end
		self.TouchMoved:Fire(input.Position, input.Delta)
	end)
	
	userInput.TouchTapInWorld:Connect(function(position, processed)
		if (processed) then return end
		self.TouchTapInWorld:Fire(position)
	end)
	
	userInput.TouchPinch:Connect(function(touchPositions, scale, velocity, state, processed)
		if (processed) then return end
		self.TouchPinch:Fire(touchPositions, scale, velocity, state)
	end)

	userInput.TouchLongPress:Connect(function(touchPositions, state, processed)
		if (processed) then return end
		self.TouchLongPress:Fire(touchPositions, state)
	end)

	userInput.TouchPan:Connect(function(touchPositions, totalTranslation, velocity, state, processed)
		if (processed) then return end
		self.TouchPan:Fire(touchPositions, totalTranslation, velocity, state)
	end)

	userInput.TouchRotate:Connect(function(touchPositions, rotation, velocity, state, processed)
		if (processed) then return end
		self.TouchRotate:Fire(touchPositions, rotation, velocity, state)
	end)

	userInput.TouchSwipe:Connect(function(swipeDirection, numberOfTouches, processed)
		if (processed) then return end
		self.TouchSwipe:Fire(swipeDirection, numberOfTouches)
	end)

	userInput.TouchTap:Connect(function(touchPositions, processed)
		if (processed) then return end
		self.TouchTap:Fire(touchPositions)
	end)

	self.GetDeviceAcceleration = userInput.GetDeviceAcceleration
	self.GetDeviceGravity = userInput.GetDeviceGravity
	self.GetDeviceRotation = userInput.GetDeviceRotation
	self.DeviceAccelerationChanged = userInput.DeviceAccelerationChanged
	self.DeviceGravityChanged = userInput.DeviceGravityChanged
	self.DeviceRotationChanged = userInput.DeviceRotationChanged
	
end


return Mobile
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="42">
              <Properties>
                <string name="Name">Mouse</string>
                <string name="Source"><![CDATA[-- Mouse
-- Stephen Leitnick
-- December 28, 2017

--[[
	
	Vector2        Mouse:GetPosition()
	Vector2        Mouse:GetDelta()
	Void           Mouse:Lock()
	Void           Mouse:LockCenter()
	Void           Mouse:Unlock()
	Ray            Mouse:GetRay(distance)
	Ray            Mouse:GetRayFromXY(x, y)
	Void           Mouse:SetMouseIcon(iconId)
	Void           Mouse:SetMouseIconEnabled(isEnabled)
	Boolean        Mouse:IsMouseIconEnabled()
	Boolean        Mouse:IsButtonPressed(mouseButton)
	RaycastResult  Mouse:Raycast(raycastParams [, distance = 1000])
	
	Mouse.LeftDown()
	Mouse.LeftUp()
	Mouse.RightDown()
	Mouse.RightUp()
	Mouse.MiddleDown()
	Mouse.MiddleUp()
	Mouse.Moved()
	Mouse.Scrolled(amount)
	
--]]



local Mouse = {}

local RAY_DISTANCE = 1000

local playerMouse = game:GetService("Players").LocalPlayer:GetMouse()
local userInput = game:GetService("UserInputService")
local cam = workspace.CurrentCamera

local workspace = workspace


function Mouse:GetPosition()
	return userInput:GetMouseLocation()
end


function Mouse:GetDelta()
	return userInput:GetMouseDelta()
end


function Mouse:Lock()
	userInput.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
end


function Mouse:LockCenter()
	userInput.MouseBehavior = Enum.MouseBehavior.LockCenter
end


function Mouse:Unlock()
	userInput.MouseBehavior = Enum.MouseBehavior.Default
end


function Mouse:SetMouseIcon(iconId)
	playerMouse.Icon = (iconId and ("rbxassetid://" .. iconId) or "")
end


function Mouse:SetMouseIconEnabled(enabled)
	userInput.MouseIconEnabled = enabled
end


function Mouse:IsMouseIconEnabled()
	return userInput.MouseIconEnabled
end


function Mouse:IsButtonPressed(mouseButton)
	return userInput:IsMouseButtonPressed(mouseButton)
end


function Mouse:GetRay(distance)
	local mousePos = userInput:GetMouseLocation()
	local viewportMouseRay = cam:ViewportPointToRay(mousePos.X, mousePos.Y)
	return Ray.new(viewportMouseRay.Origin, viewportMouseRay.Direction * distance)
end


function Mouse:GetRayFromXY(x, y)
	local viewportMouseRay = cam:ViewportPointToRay(x, y)
	return Ray.new(viewportMouseRay.Origin, viewportMouseRay.Direction)
end


function Mouse:Cast(ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
	warn("Mouse:Cast() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRay(self:GetRay(RAY_DISTANCE), ignoreDescendantsInstance, terrainCellsAreCubes, ignoreWater)
end


function Mouse:CastWithIgnoreList(ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
	warn("Mouse:CastWithIgnoreList() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRayWithIgnoreList(self:GetRay(RAY_DISTANCE), ignoreDescendantsTable, terrainCellsAreCubes, ignoreWater)
end


function Mouse:CastWithWhitelist(whitelistDescendantsTable, ignoreWater)
	warn("Mouse:CastWithWhitelist() is deprecated; please use Mouse:Raycast(raycastParams) instead")
	return workspace:FindPartOnRayWithWhitelist(self:GetRay(RAY_DISTANCE), whitelistDescendantsTable, ignoreWater)
end


function Mouse:Raycast(raycastParams, distance)
	local mousePos = userInput:GetMouseLocation()
	local viewportMouseRay = cam:ViewportPointToRay(mousePos.X, mousePos.Y)
	return workspace:Raycast(viewportMouseRay.Origin, viewportMouseRay.Direction * (distance or RAY_DISTANCE), raycastParams)
end


function Mouse:Init()
	
	self.LeftDown   = self.Shared.Signal.new()
	self.LeftUp     = self.Shared.Signal.new()
	self.RightDown  = self.Shared.Signal.new()
	self.RightUp    = self.Shared.Signal.new()
	self.MiddleDown = self.Shared.Signal.new()
	self.MiddleUp   = self.Shared.Signal.new()
	self.Moved      = self.Shared.Signal.new()
	self.Scrolled   = self.Shared.Signal.new()
	
	userInput.InputBegan:Connect(function(input, processed)
		if (processed) then return end
		if (input.UserInputType == Enum.UserInputType.MouseButton1) then
			self.LeftDown:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton2) then
			self.RightDown:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton3) then
			self.MiddleDown:Fire()
		end
	end)
	
	userInput.InputEnded:Connect(function(input, _processed)
		if (input.UserInputType == Enum.UserInputType.MouseButton1) then
			self.LeftUp:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton2) then
			self.RightUp:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseButton3) then
			self.MiddleUp:Fire()
		end
	end)
	
	userInput.InputChanged:Connect(function(input, processed)
		if (input.UserInputType == Enum.UserInputType.MouseMovement) then
			self.Moved:Fire()
		elseif (input.UserInputType == Enum.UserInputType.MouseWheel) then
			if (not processed) then
				self.Scrolled:Fire(input.Position.Z)
			end
		end
	end)
	
end


return Mouse
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="43">
          <Properties>
            <string name="Name">Internal</string>
          </Properties>
          <Item class="LocalScript" referent="44">
            <Properties>
              <string name="Name">AeroClient</string>
              <string name="Source"><![CDATA[-- Aero Client
-- Stephen Leitnick
-- July 21, 2017



local Aero = {
	Controllers = {};
	Modules = {};
	Shared = {};
	Services = {};
	Player = game:GetService("Players").LocalPlayer;
}

local NO_CACHE = {}

local mt = {__index = Aero}

local controllersFolder = script.Parent.Parent:WaitForChild("Controllers")
local modulesFolder = script.Parent.Parent:WaitForChild("Modules")
local sharedFolder = game:GetService("ReplicatedStorage"):WaitForChild("Aero"):WaitForChild("Shared")
local internalFolder = game:GetService("ReplicatedStorage").Aero:WaitForChild("Internal")
local modulesAwaitingStart = {}

local SpawnNow = require(sharedFolder:WaitForChild("Thread"):Clone()).SpawnNow
local Promise = require(sharedFolder:WaitForChild("Promise"):Clone())
local Settings = require(internalFolder:WaitForChild("Settings"))

local settingsPerTbl = {}


local function PreventEventRegister()
	error("Cannot register event after Init method")
end


function Aero:RegisterEvent(eventName)
	local event = self.Shared.Signal.new()
	self._events[eventName] = event
	return event
end


function Aero:FireEvent(eventName, ...)
	self._events[eventName]:Fire(...)
end


function Aero:ConnectEvent(eventName, func)
	return self._events[eventName]:Connect(func)
end


function Aero:WaitForEvent(eventName)
	return self._events[eventName]:Wait()
end


function Aero:WrapModule(tbl)
	assert(type(tbl) == "table", "Expected table for argument")
	tbl._events = {}
	setmetatable(tbl, mt)
	local objSettings = (settingsPerTbl[tbl] or Settings:GetDefault())
	if (type(tbl.Init) == "function" and not (objSettings.PreventInit or tbl.__aeroPreventInit)) then
		tbl:Init()
	end
	if (type(tbl.Start) == "function" and not (objSettings.PreventStart or tbl.__aeroPreventStart)) then
		if (modulesAwaitingStart) then
			modulesAwaitingStart[#modulesAwaitingStart + 1] = tbl
		else
			SpawnNow(tbl.Start, tbl)
		end
	end
	return tbl
end


local function LoadService(serviceFolder, servicesTbl)
	local service = {}
	servicesTbl[serviceFolder.Name] = service
	for _,v in ipairs(serviceFolder:GetChildren()) do
		if (v:IsA("RemoteEvent")) then
			local event = Aero.Shared.Signal.new()
			local fireEvent = event.Fire
			function event:Fire(...)
				v:FireServer(...)
			end
			v.OnClientEvent:Connect(function(...)
				fireEvent(event, ...)
			end)
			service[v.Name] = event
		elseif (v:IsA("RemoteFunction")) then
			local cacheTTL = v:FindFirstChild("Cache")
			if (cacheTTL) then
				cacheTTL = cacheTTL.Value
				local methodName = v.Name
				local cache = NO_CACHE
				local lastCacheTime = 0
				local fetchingPromise
				service[methodName] = function(self, ...)
					local now = tick()
					if (fetchingPromise) then
						local _,c = fetchingPromise:Await()
						return table.unpack(c)
					elseif (cache == NO_CACHE or (cacheTTL > 0 and (now - lastCacheTime) > cacheTTL)) then
						lastCacheTime = now
						local args = table.pack(...)
						fetchingPromise = Promise.new(function(resolve, _reject)
							resolve(table.pack(v:InvokeServer(table.unpack(args))))
						end)
						local success, _cache = fetchingPromise:Await()
						if (success) then
							cache = _cache
						end
						fetchingPromise = nil
						return table.unpack(_cache)
					end
					return table.unpack(cache)
				end
			else
				service[v.Name] = function(self, ...)
					return v:InvokeServer(...)
				end
			end
		end
	end
	return service
end


local function LoadServices()
	local remoteServices = game:GetService("ReplicatedStorage"):WaitForChild("Aero"):WaitForChild("AeroRemoteServices")
	local function LoadAllServices(folder, servicesTbl)
		for _,serviceFolder in ipairs(folder:GetChildren()) do
			if (serviceFolder:IsA("Folder")) then
				local service = LoadService(serviceFolder, servicesTbl)
				if (next(service) == nil) then
					LoadAllServices(serviceFolder, service)
				end
			end
		end
	end
	LoadAllServices(remoteServices, Aero.Services)
end


-- Setup table to load modules on demand:
local function LazyLoadSetup(tbl, folder)
	setmetatable(tbl, {
		__index = function(t, i)
			local child = folder[i]
			if (child:IsA("ModuleScript")) then
				local objSettings = Settings:Get(child)
				local obj = require(child)
				settingsPerTbl[obj] = objSettings
				rawset(t, i, obj)
				if (type(obj) == "table" and not objSettings.Standalone) then
					-- only wrap module if it's actually a table, and not a table disguised as a function
					local objMetatable = getmetatable(obj)
					if (not (objMetatable and objMetatable.__call)) then
						Aero:WrapModule(obj)
					end
				end
				return obj
			elseif (child:IsA("Folder")) then
				local nestedTbl = {}
				rawset(t, i, nestedTbl)
				LazyLoadSetup(nestedTbl, child)
				return nestedTbl
			end
		end;
	})
end


local function LoadController(module, controllersTbl)
	local controllerSettings = Settings:Get(module)
	local controller = require(module)
	controllersTbl[module.Name] = controller
	controller._events = {}
	setmetatable(controller, mt)
	settingsPerTbl[controller] = controllerSettings
end


local function InitController(controller)
	if (type(controller.Init) == "function") then
		controller:Init()
	end
	controller.RegisterEvent = PreventEventRegister
end


local function StartController(controller)
	-- Start controllers on separate threads:
	if (type(controller.Start) == "function") then
		SpawnNow(controller.Start, controller)
	end
end


local function Init()
	
	-- Load controllers:
	local function LoadAllControllers(parent, controllersTbl)
		for _,child in ipairs(parent:GetChildren()) do
			if (child:IsA("ModuleScript")) then
				if (not Settings:IsSettingsModule(child)) then
					LoadController(child, controllersTbl)
				end
			elseif (child:IsA("Folder")) then
				local tbl = {}
				controllersTbl[child.Name] = tbl
				LoadAllControllers(child, tbl)
			end
		end
	end
	
	-- Initialize controllers:
	local function InitAllControllers(controllers)
		-- Collect all controllers:
		local controllerTables = {}
		local function CollectControllers(ctrls)
			for _,controller in pairs(ctrls) do
				if (getmetatable(controller) == mt) then
					controllerTables[#controllerTables + 1] = controller
				else
					CollectControllers(controller)
				end
			end
		end
		CollectControllers(controllers)
		-- Sort controllers by optional Order setting or __aeroOrder field:
		local function GetOrder(controller)
			local ctrlSettings = settingsPerTbl[controller]
			local order
			if (type(ctrlSettings.Order) == "number") then
				order = ctrlSettings.Order
			elseif (type(controller.__aeroOrder) == "number") then
				order = controller.__aeroOrder
			else
				order = Settings.InternalSettings.DefaultOrder
			end
			return order
		end
		table.sort(controllerTables, function(a, b)
			return (GetOrder(a) < GetOrder(b))
		end)
		-- Initialize controllers:
		for _,controller in ipairs(controllerTables) do
			InitController(controller)
		end
	end
	
	-- Start controllers:
	local function StartAllControllers(controllers)
		for _,controller in pairs(controllers) do
			if (getmetatable(controller) == mt) then
				StartController(controller)
			else
				StartAllControllers(controller)
			end
		end
	end

	-- Start modules that were already loaded:
	local function StartLoadedModules()
		for _,tbl in pairs(modulesAwaitingStart) do
			SpawnNow(tbl.Start, tbl)
		end
		modulesAwaitingStart = nil
	end

	------------------------------------------------------
	
	-- Lazy load modules:
	LazyLoadSetup(Aero.Modules, modulesFolder)
	LazyLoadSetup(Aero.Shared, sharedFolder)
	
	-- Load server-side services:
	LoadServices()

	-- Load, init, and start controllers:
	LoadAllControllers(controllersFolder, Aero.Controllers)
	InitAllControllers(Aero.Controllers)
	StartAllControllers(Aero.Controllers)
	StartLoadedModules()

	-- Expose client framework globally:
	_G.Aero = Aero
	
end


Init()
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="45">
          <Properties>
            <string name="Name">Modules</string>
          </Properties>
          <Item class="ModuleScript" referent="46">
            <Properties>
              <string name="Name">CameraShaker</string>
              <string name="Source">-- Camera Shaker
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShaker.CameraShakeInstance
	CameraShaker.Presets
	
	cameraShaker = CameraShaker.new(renderPriority, callbackFunction)
	
	CameraShaker:Start()
	CameraShaker:Stop()
	CameraShaker:StopSustained([fadeOutTime])
	CameraShaker:Shake(shakeInstance)
	CameraShaker:ShakeSustain(shakeInstance)
	CameraShaker:ShakeOnce(magnitude, roughness [, fadeInTime, fadeOutTime, posInfluence, rotInfluence])
	CameraShaker:StartShake(magnitude, roughness [, fadeInTime, posInfluence, rotInfluence])
	
	
	
	EXAMPLE:
	
		local camShake = CameraShaker.new(Enum.RenderPriority.Camera.Value, function(shakeCFrame)
			camera.CFrame = playerCFrame * shakeCFrame
		end)
		
		camShake:Start()
		
		-- Explosion shake:
		camShake:Shake(CameraShaker.Presets.Explosion)
		
		wait(1)
		
		-- Custom shake:
		camShake:ShakeOnce(3, 1, 0.2, 1.5)

		-- Sustained shake:
		camShake:ShakeSustain(CameraShaker.Presets.Earthquake)

		-- Stop all sustained shakes:
		camShake:StopSustained(1) -- Argument is the fadeout time (defaults to the same as fadein time if not supplied)

		-- Stop only one sustained shake:
		shakeInstance = camShake:ShakeSustain(CameraShaker.Presets.Earthquake)
		wait(2)
		shakeInstance:StartFadeOut(1) -- Argument is the fadeout time
	
	
	NOTE:
	
		This was based entirely on the EZ Camera Shake asset for Unity3D. I was given written
		permission by the developer, Road Turtle Games, to port this to Roblox.
		
		Original asset link: https://assetstore.unity.com/packages/tools/camera/ez-camera-shake-33148

		GitHub repository: https://github.com/Sleitnick/RbxCameraShaker
	
	
--]]



local CameraShaker = {}
CameraShaker.__index = CameraShaker
CameraShaker.__aeroPreventStart = true

local profileBegin = debug.profilebegin
local profileEnd = debug.profileend
local profileTag = "CameraShakerUpdate"

local V3 = Vector3.new
local CF = CFrame.new
local ANG = CFrame.Angles
local RAD = math.rad
local v3Zero = V3()

local CameraShakeInstance = require(script.CameraShakeInstance)
local CameraShakeState = CameraShakeInstance.CameraShakeState

local defaultPosInfluence = V3(0.15, 0.15, 0.15)
local defaultRotInfluence = V3(1, 1, 1)

local http = game:GetService("HttpService")


CameraShaker.CameraShakeInstance = CameraShakeInstance
CameraShaker.Presets = require(script.CameraShakePresets)


function CameraShaker.new(renderPriority, callback)
	
	assert(type(renderPriority) == "number", "RenderPriority must be a number (e.g.: Enum.RenderPriority.Camera.Value)")
	assert(type(callback) == "function", "Callback must be a function")
	
	local self = setmetatable({
		_running = false;
		_renderName = ("CameraShaker" .. http:GenerateGUID(false));
		_renderPriority = renderPriority;
		_posAddShake = v3Zero;
		_rotAddShake = v3Zero;
		_camShakeInstances = {};
		_removeInstances = {};
		_callback = callback;
	}, CameraShaker)
	
	return self
	
end


function CameraShaker:Start()
	if (self._running) then return end
	self._running = true
	local callback = self._callback
	game:GetService("RunService"):BindToRenderStep(self._renderName, self._renderPriority, function(dt)
		profileBegin(profileTag)
		local cf = self:Update(dt)
		profileEnd()
		callback(cf)
	end)
end


function CameraShaker:Stop()
	if (not self._running) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._renderName)
	self._running = false
end


function CameraShaker:StopSustained(duration)
	for _,c in ipairs(self._camShakeInstances) do
		if (c.fadeOutDuration == 0) then
			c:StartFadeOut(duration or c.fadeInDuration)
		end
	end
end


function CameraShaker:Update(dt)
	
	local posAddShake = v3Zero
	local rotAddShake = v3Zero
	
	local instances = self._camShakeInstances
	
	-- Update all instances:
	for i = 1,#instances do
		
		local c = instances[i]
		local state = c:GetState()
		
		if (state == CameraShakeState.Inactive and c.DeleteOnInactive) then
			self._removeInstances[#self._removeInstances + 1] = i
		elseif (state ~= CameraShakeState.Inactive) then
			local shake = c:UpdateShake(dt)
			posAddShake = posAddShake + (shake * c.PositionInfluence)
			rotAddShake = rotAddShake + (shake * c.RotationInfluence)
		end
		
	end
	
	-- Remove dead instances:
	for i = #self._removeInstances,1,-1 do
		local instIndex = self._removeInstances[i]
		table.remove(instances, instIndex)
		self._removeInstances[i] = nil
	end
	
	return CF(posAddShake) *
			ANG(0, RAD(rotAddShake.Y), 0) *
			ANG(RAD(rotAddShake.X), 0, RAD(rotAddShake.Z))
	
end


function CameraShaker:Shake(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:ShakeSustain(shakeInstance)
	assert(type(shakeInstance) == "table" and shakeInstance._camShakeInstance, "ShakeInstance must be of type CameraShakeInstance")
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	shakeInstance:StartFadeIn(shakeInstance.fadeInDuration)
	return shakeInstance
end


function CameraShaker:ShakeOnce(magnitude, roughness, fadeInTime, fadeOutTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


function CameraShaker:StartShake(magnitude, roughness, fadeInTime, posInfluence, rotInfluence)
	local shakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime)
	shakeInstance.PositionInfluence = (typeof(posInfluence) == "Vector3" and posInfluence or defaultPosInfluence)
	shakeInstance.RotationInfluence = (typeof(rotInfluence) == "Vector3" and rotInfluence or defaultRotInfluence)
	shakeInstance:StartFadeIn(fadeInTime)
	self._camShakeInstances[#self._camShakeInstances + 1] = shakeInstance
	return shakeInstance
end


return CameraShaker</string>
            </Properties>
            <Item class="ModuleScript" referent="47">
              <Properties>
                <string name="Name">CameraShakeInstance</string>
                <string name="Source">-- Camera Shake Instance
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	cameraShakeInstance = CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
--]]



local CameraShakeInstance = {}
CameraShakeInstance.__index = CameraShakeInstance

local V3 = Vector3.new
local NOISE = math.noise


CameraShakeInstance.CameraShakeState = {
	FadingIn = 0;
	FadingOut = 1;
	Sustained = 2;
	Inactive = 3;
}


function CameraShakeInstance.new(magnitude, roughness, fadeInTime, fadeOutTime)
	
	if (fadeInTime == nil) then fadeInTime = 0 end
	if (fadeOutTime == nil) then fadeOutTime = 0 end
	
	assert(type(magnitude) == "number", "Magnitude must be a number")
	assert(type(roughness) == "number", "Roughness must be a number")
	assert(type(fadeInTime) == "number", "FadeInTime must be a number")
	assert(type(fadeOutTime) == "number", "FadeOutTime must be a number")
	
	local self = setmetatable({
		Magnitude = magnitude;
		Roughness = roughness;
		PositionInfluence = V3();
		RotationInfluence = V3();
		DeleteOnInactive = true;
		roughMod = 1;
		magnMod = 1;
		fadeOutDuration = fadeOutTime;
		fadeInDuration = fadeInTime;
		sustain = (fadeInTime > 0);
		currentFadeTime = (fadeInTime > 0 and 0 or 1);
		tick = Random.new():NextNumber(-100, 100);
		_camShakeInstance = true;
	}, CameraShakeInstance)
	
	return self
	
end


function CameraShakeInstance:UpdateShake(dt)
	
	local _tick = self.tick
	local currentFadeTime = self.currentFadeTime
	
	local offset = V3(
		NOISE(_tick, 0) * 0.5,
		NOISE(0, _tick) * 0.5,
		NOISE(_tick, _tick) * 0.5
	)
	
	if (self.fadeInDuration > 0 and self.sustain) then
		if (currentFadeTime &lt; 1) then
			currentFadeTime = currentFadeTime + (dt / self.fadeInDuration)
		elseif (self.fadeOutDuration > 0) then
			self.sustain = false
		end
	end
	
	if (not self.sustain) then
		currentFadeTime = currentFadeTime - (dt / self.fadeOutDuration)
	end
	
	if (self.sustain) then
		self.tick = _tick + (dt * self.Roughness * self.roughMod)
	else
		self.tick = _tick + (dt * self.Roughness * self.roughMod * currentFadeTime)
	end
	
	self.currentFadeTime = currentFadeTime
	
	return offset * self.Magnitude * self.magnMod * currentFadeTime
	
end


function CameraShakeInstance:StartFadeOut(fadeOutTime)
	if (fadeOutTime == 0) then
		self.currentFadeTime = 0
	end
	self.fadeOutDuration = fadeOutTime
	self.fadeInDuration = 0
	self.sustain = false
end


function CameraShakeInstance:StartFadeIn(fadeInTime)
	if (fadeInTime == 0) then
		self.currentFadeTime = 1
	end
	self.fadeInDuration = fadeInTime or self.fadeInDuration
	self.fadeOutDuration = 0
	self.sustain = true
end


function CameraShakeInstance:GetScaleRoughness()
	return self.roughMod
end


function CameraShakeInstance:SetScaleRoughness(v)
	self.roughMod = v
end


function CameraShakeInstance:GetScaleMagnitude()
	return self.magnMod
end


function CameraShakeInstance:SetScaleMagnitude(v)
	self.magnMod = v
end


function CameraShakeInstance:GetNormalizedFadeTime()
	return self.currentFadeTime
end


function CameraShakeInstance:IsShaking()
	return (self.currentFadeTime > 0 or self.sustain)
end


function CameraShakeInstance:IsFadingOut()
	return ((not self.sustain) and self.currentFadeTime > 0)
end


function CameraShakeInstance:IsFadingIn()
	return (self.currentFadeTime &lt; 1 and self.sustain and self.fadeInDuration > 0)
end


function CameraShakeInstance:GetState()
	if (self:IsFadingIn()) then
		return CameraShakeInstance.CameraShakeState.FadingIn
	elseif (self:IsFadingOut()) then
		return CameraShakeInstance.CameraShakeState.FadingOut
	elseif (self:IsShaking()) then
		return CameraShakeInstance.CameraShakeState.Sustained
	else
		return CameraShakeInstance.CameraShakeState.Inactive
	end
end


return CameraShakeInstance</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="48">
              <Properties>
                <string name="Name">CameraShakePresets</string>
                <string name="Source"><![CDATA[-- Camera Shake Presets
-- Stephen Leitnick
-- February 26, 2018

--[[
	
	CameraShakePresets.Bump
	CameraShakePresets.Explosion
	CameraShakePresets.Earthquake
	CameraShakePresets.GentleSway
	CameraShakePresets.BadTrip
	CameraShakePresets.HandheldCamera
	CameraShakePresets.Vibration
	CameraShakePresets.RoughDriving
	
--]]



local CameraShakeInstance = require(script.Parent.CameraShakeInstance)

local CameraShakePresets = {
	
	
	-- A high-magnitude, short, yet smooth shake.
	-- Should happen once.
	Bump = function()
		local c = CameraShakeInstance.new(2.5, 4, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(0.15, 0.15, 0.15)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
	-- An intense and rough shake.
	-- Should happen once.
	Explosion = function()
		local c = CameraShakeInstance.new(5, 10, 0, 1.5)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(4, 1, 1)
		return c
	end;
	
	
	-- A continuous, rough shake
	-- Sustained.
	Earthquake = function()
		local c = CameraShakeInstance.new(0.6, 3.5, 2, 10)
		c.PositionInfluence = Vector3.new(0.25, 0.25, 0.25)
		c.RotationInfluence = Vector3.new(1, 1, 4)
		return c
	end;
	
	
	-- A gentle left/right/up/down sway. Good for intro screens/landscapes.
	-- Sustained.
	GentleSway = function()
		local c = CameraShakeInstance.new(0.65, 0.08, 0.1, 0.75)
		c.PositionInfluence = Vector3.new(1.20, 0.35, 0.05)
		c.RotationInfluence = Vector3.new(0.02, 0.02, 0.02)
		return c
	end;
	
	
	-- A bizarre shake with a very high magnitude and low roughness.
	-- Sustained.
	BadTrip = function()
		local c = CameraShakeInstance.new(10, 0.15, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0.15)
		c.RotationInfluence = Vector3.new(2, 1, 4)
		return c
	end;
	
	
	-- A subtle, slow shake.
	-- Sustained.
	HandheldCamera = function()
		local c = CameraShakeInstance.new(1, 0.25, 5, 10)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 0.5, 0.5)
		return c
	end;
	
	
	-- A very rough, yet low magnitude shake.
	-- Sustained.
	Vibration = function()
		local c = CameraShakeInstance.new(0.4, 20, 2, 2)
		c.PositionInfluence = Vector3.new(0, 0.15, 0)
		c.RotationInfluence = Vector3.new(1.25, 0, 4)
		return c
	end;
	
	
	-- A slightly rough, medium magnitude shake.
	-- Sustained.
	RoughDriving = function()
		local c = CameraShakeInstance.new(1, 2, 1, 1)
		c.PositionInfluence = Vector3.new(0, 0, 0)
		c.RotationInfluence = Vector3.new(1, 1, 1)
		return c
	end;
	
	
}


return setmetatable({}, {
	__index = function(_t, i)
		local f = CameraShakePresets[i]
		if (type(f) == "function") then
			return f()
		end
		error("No preset found with index \"" .. i .. "\"")
	end;
})
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="49">
            <Properties>
              <string name="Name">PID</string>
              <string name="Source">-- PID
-- August 11, 2020

--[[

	PID stands for Proportional-Integral-Derivative. One example of PID controllers in
	real-life is to control the input to each motor of a drone to keep it stabilized.
	Another example is cruise-control on a car.

	-----------------------------------------------

	Constructor:

		pid = PID.new(min, max, kP, kD, kI)


	Methods:

		pid:Calculate(dt, setpoint, pv)
		> Calculates and returns the new value
			> dt: DeltaTime
			> setpoint: The current point
			> pv: The process variable (i.e. goal)

		pid:Reset()
		> Resets the PID

	-----------------------------------------------

--]]


local PID = {}
PID.__index = PID


function PID.new(min, max, kp, kd, ki)
	local self = setmetatable({}, PID)
	self._min = min
	self._max = max
	self._kp = kp
	self._kd = kd
	self._ki = ki
	self._preError = 0
	self._integral = 0
	return self
end


function PID:Reset()
	self._preError = 0
	self._integral = 0
end


function PID:Calculate(dt, setpoint, pv)
	local err = (setpoint - pv)
	local pOut = (self._kp * err)
	self._integral += (err * dt)
	local iOut = (self._ki * self._integral)
	local deriv = ((err - self._preError) / dt)
	local dOut = (self._kd * deriv)
	local output = math.clamp((pOut + iOut + dOut), self._min, self._max)
	self._preError = err
	return output
end


function PID:SetMinMax(min, max)
	self._min = min
	self._max = max
end


return PID</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="50">
            <Properties>
              <string name="Name">Smooth</string>
              <string name="Source">-- Smooth
-- Stephen Leitnick
-- June 3, 2018

--[[
	
	This is a wrapper for the SmoothDamp module. It stores
	all needed variables internally for ease of use.
	
	-------------------------------------------------------------------------

	local smooth = Smooth.new(Vector3 initialValue, Number smoothTime)
	
	smooth.Value
	smooth.Goal
	smooth.SmoothTime
	
	smooth:Update([Vector goal])
	smooth:UpdateAngle([Vector goal])
	smooth:SetMaxSpeed(Number speed)
	smooth:GetMaxSpeed()

	-------------------------------------------------------------------------

	EXAMPLE:

		local smoothPosition = Smooth.new(part.Position, 0.5)

		runService:BindToRenderStep("Example", 0, function()
			local position = smoothPosition:Update(mouse.Hit.p)
			part.Position = position
		end)

--]]



local Smooth = {}
Smooth.__index = Smooth

local SmoothDamp = require(script:WaitForChild("SmoothDamp"))


function Smooth.new(initialValue, smoothTime)

	assert(typeof(initialValue) == "Vector3", "initialValue should be Vector3")
	assert(typeof(smoothTime) == "number", "smoothTime should be a number")
	assert(smoothTime >= 0, "smoothTime must be a positive number")
	
	local self = setmetatable({
		Value = initialValue;
		Goal = initialValue;
		SmoothTime = smoothTime;
	}, Smooth)
	
	self._smoothDamp = SmoothDamp.new()
	
	return self
	
end


function Smooth:Update(goal)
	if (goal) then
		self.Goal = goal
	else
		goal = self.Goal
	end
	local value = self._smoothDamp:Update(self.Value, goal, self.SmoothTime)
	self.Value = value
	return value
end


function Smooth:UpdateAngle(goal)
	if (goal) then
		self.Goal = goal
	else
		goal = self.Goal
	end
	local value = self._smoothDamp:UpdateAngle(self.Value, goal, self.SmoothTime)
	self.Value = value
	return value
end


function Smooth:SetMaxSpeed(speed)
	self._smoothDamp.MaxSpeed = speed
end


function Smooth:GetMaxSpeed()
	return self._smoothDamp.MaxSpeed
end


return Smooth</string>
            </Properties>
            <Item class="ModuleScript" referent="51">
              <Properties>
                <string name="Name">SmoothDamp</string>
                <string name="Source"><![CDATA[-- Smooth Damp
-- Stephen Leitnick
-- January 30, 2017

--[[

	local SmoothDamp = require(this)

	smooth = SmoothDamp.new()
	smooth.MaxSpeed
	smooth:Update(currentVector, targetVector, smoothTime)
	smooth:UpdateAngle(currentVector, targetVector, smoothTime)


	Use UpdateAngle if smoothing out angles. The only difference is that
	it makes sure angles wrap properly (in radians). For instance, if
	damping a rotating wheel, UpdateAngle should be used.


	-- Example:

	local smooth = SmoothDamp.new()
	function Update()
		local current = camera.CFrame.p
		local target = (part.CFrame * CFrame.new(0, 5, -10)).p
		local camPos = smooth:Update(current, target, 0.2)
		camera.CFrame = CFrame.new(camPos, part.Position)
	end
--]]


----------------------------------------------------------------------------------------------------------------

local function DeltaAngle(current, target)
	local n = ((target - current) % 6.2831853071796)
	return (n > 3.1415926535898 and (n - 6.2831853071796) or n)
end

local function DeltaAngleV3(p1, p2)
	return Vector3.new(DeltaAngle(p1.X, p2.X), DeltaAngle(p1.Y, p2.Y), DeltaAngle(p1.Z, p2.Z))
end

----------------------------------------------------------------------------------------------------------------

local SmoothDamp = {}
SmoothDamp.__index = SmoothDamp

function SmoothDamp.new()
	return setmetatable({
		MaxSpeed = math.huge;
		_update = tick();
		_velocity = Vector3.new();
	}, SmoothDamp)
end

function SmoothDamp:Update(current, target, smoothTime)
	local currentVelocity = self._velocity
	local now = tick()
	local deltaTime = (now - self._update)
	smoothTime = math.max(0.0001, smoothTime)

	local num = (2 / smoothTime)
	local num2 = (num * deltaTime)
	local d = (1 / (1 + num2 + 0.48 * num2 * num2 + 0.235 * num2 * num2 * num2))

	local vector = (current - target)
	local vector2 = target

	local maxLength = (self.MaxSpeed * smoothTime)
	vector = vector.Magnitude > maxLength and (vector.Unit * maxLength) or vector -- Clamp magnitude.
	target = (current - vector)

	local vector3 = ((currentVelocity + num * vector) * deltaTime)
	currentVelocity = ((currentVelocity - num * vector3) * d)

	local vector4 = (target + (vector + vector3) * d)
	if ((vector2 - current):Dot(vector4 - vector2) > 0) then
		vector4 = vector2
		currentVelocity = ((vector4 - vector2) / deltaTime)
	end

	self._velocity = currentVelocity
	self._update = now
	return vector4
end

function SmoothDamp:UpdateAngle(current, target, smoothTime)
	return self:Update(current, (current + DeltaAngleV3(current, target)), smoothTime)
end

return SmoothDamp
]]></string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="52">
            <Properties>
              <string name="Name">Tween</string>
              <string name="Source">-- Tween
-- Stephen Leitnick
-- June 21, 2017

--[[
	
	Native:
		
		tween = Tween.FromService(instance, tweenInfo, properties)
		
		See Wiki page on Tween object for methods and such
		
		
	Custom:
	
		tween = Tween.new(tweenInfo, callbackFunction)
		
		tween.TweenInfo
		tween.Callback
		tween.PlaybackState
		
		tween:Play()
		tween:Pause()
		tween:Cancel()
		
		tween.Completed(playbackState)
		tween.PlaybackStateChanged(playbackState)
	
	
	Custom Example:
	
		tween = Tween.new(TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true, 0), function(n)
			print(n)
		end)
		
		tween:Play()
		tween.Completed:Wait()
	
--]]



local Tween = {}
Tween.__index = Tween


Tween.Easing = require(script:WaitForChild("Easing"))


function Tween.new(tweenInfo, callback)
	
	do
		-- Verify callback is function:
		assert(typeof(callback) == "function", "Callback argument must be a function")
		
		-- Verify tweenInfo:
		local typeOfTweenInfo = typeof(tweenInfo)
		assert(typeOfTweenInfo == "TweenInfo" or typeOfTweenInfo == "table", "TweenInfo must be of type TweenInfo or table")
		
		-- Defaults:
		if (typeOfTweenInfo == "table") then
			if (tweenInfo.Time == nil) then tweenInfo.Time = 1 end
			if (tweenInfo.EasingStyle == nil) then tweenInfo.EasingStyle = Enum.EasingStyle.Quad end
			if (tweenInfo.EasingDirection == nil) then tweenInfo.EasingDirection = Enum.EasingDirection.Out end
			if (tweenInfo.RepeatCount == nil) then tweenInfo.RepeatCount = 0 end
			if (tweenInfo.Reverses == nil) then tweenInfo.Reverses = false end
			if (tweenInfo.DelayTime == nil) then tweenInfo.DelayTime = 0 end
		end
		
	end
	
	local completed = Instance.new("BindableEvent")
	local playbackStateChanged = Instance.new("BindableEvent")
	
	local self = setmetatable({
		
		TweenInfo = tweenInfo;
		Callback = callback;
		PlaybackState = Enum.PlaybackState.Begin;
		Completed = completed.Event;
		PlaybackStateChanged = playbackStateChanged.Event;
		
		_id = "tween_" .. game:GetService("HttpService"):GenerateGUID(false);
		_playing = false;
		_paused = false;
		_completed = completed;
		_playbackStateChanged = playbackStateChanged;
		_elapsedTime = 0;
		_repeated = 0;
		_reversing = false;
		_elapsedDelayTime = 0;
		
	}, Tween)
	
	return self
	
end


function Tween:ResetState()
	self._playing = false
	self._paused = false
	self._elapsedTime = 0
	self._repeated = 0
	self._reversing = false
	self._elapsedDelayTime = 0
end


function Tween:SetPlaybackState(state)
	local lastState = self.PlaybackState
	self.PlaybackState = state
	if (state ~= lastState) then
		self._playbackStateChanged:Fire(state)
	end
end


function Tween:Play()
	
	if (self._playing and not self._paused) then return end
	self._playing = true
	self._paused = false
	
	-- Resolve easing function:
	local easingFunc
	if (typeof(self.TweenInfo) == "TweenInfo") then
		easingFunc = Tween.Easing[self.TweenInfo.EasingDirection.Name][self.TweenInfo.EasingStyle.Name]
	else
		local dir, style
		dir = typeof(self.TweenInfo.EasingDirection) == "EnumItem" and self.TweenInfo.EasingDirection.Name or self.TweenInfo.EasingDirection
		style = typeof(self.TweenInfo.EasingStyle) == "EnumItem" and self.TweenInfo.EasingStyle.Name or self.TweenInfo.EasingStyle
		easingFunc = Tween.Easing[dir][style]
		if (not self.TweenInfo.RepeatCount) then
			self.TweenInfo.RepeatCount = 0
		end
	end
	
	local tick = tick
	
	local elapsed = self._elapsedTime
	local duration = self.TweenInfo.Time
	local last = tick()
	local callback = self.Callback
	local reverses = self.TweenInfo.Reverses
	
	local elapsedDelay = self._elapsedDelayTime
	local durationDelay = self.TweenInfo.DelayTime
	
	local reversing = self._reversing
	
	local function OnCompleted()
		callback(easingFunc(duration, 0, 1, duration))
		game:GetService("RunService"):UnbindFromRenderStep(self._id)
		self.PlaybackState = Enum.PlaybackState.Completed
		self._completed:Fire(self.PlaybackState)
		self:ResetState()
	end
	
	local function IsDelayed(dt)
		if (elapsedDelay >= durationDelay) then return false end
		elapsedDelay = (elapsedDelay + dt)
		self._elapsedDelayTime = elapsedDelay
		if (elapsedDelay &lt; durationDelay) then
			self:SetPlaybackState(Enum.PlaybackState.Delayed)
		else
			self:SetPlaybackState(Enum.PlaybackState.Playing)
		end
		return (elapsedDelay &lt; durationDelay)
	end
	
	-- Tween:
	game:GetService("RunService"):BindToRenderStep(self._id, Enum.RenderPriority.Camera.Value - 1, function()
		local now = tick()
		local dt = (now - last)
		last = now
		if (IsDelayed(dt)) then return end
		elapsed = (elapsed + dt)
		self._elapsedTime = elapsed
		local notDone = (elapsed &lt; duration)
		if (notDone) then
			if (reversing) then
				callback(easingFunc(elapsed, 1, -1, duration))
			else
				callback(easingFunc(elapsed, 0, 1, duration))
			end
		else
			if ((self._repeated &lt; self.TweenInfo.RepeatCount) or reversing) then
				if (reverses) then
					reversing = (not reversing)
					self._reversing = reversing
				end
				if ((not reverses) or (reversing)) then
					self._repeated = (self._repeated + 1)
				end
				if (not reversing) then
					self._elapsedDelayTime = 0
					elapsedDelay = 0
				end
				self._elapsedTime = 0
				elapsed = 0
			else
				OnCompleted()
			end
		end
	end)
	
end


function Tween:Pause()
	if ((not self._playing) or (self._paused)) then return end
	self._paused = true
	self:SetPlaybackState(Enum.PlaybackState.Paused)
	game:GetService("RunService"):UnbindFromRenderStep(self._id)
end


function Tween:Cancel()
	if (not self._playing) then return end
	game:GetService("RunService"):UnbindFromRenderStep(self._id)
	self:ResetState()
	self:SetPlaybackState(Enum.PlaybackState.Cancelled)
	self._completed:Fire(self.PlaybackState)
end


function Tween.fromService(...)
	return game:GetService("TweenService"):Create(...)
end


Tween.FromService = Tween.fromService
Tween.New = Tween.new


return Tween</string>
            </Properties>
            <Item class="ModuleScript" referent="53">
              <Properties>
                <string name="Name">Easing</string>
                <string name="Source"><![CDATA[-- Easing
-- Stephen Leitnick
-- June 21, 2017

-- Source: https://github.com/RoStrap/Interpolation/blob/master/EasingFunctions.lua

--[[
	Disclaimer for Robert Penner's Easing Equations license:

	TERMS OF USE - EASING EQUATIONS

	Open source under the BSD License.

	Copyright  2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = beginning value
-- c = change in value same as: ending - beginning
-- d = duration (total time)

-- Where applicable
-- a = amplitude
-- p = period

local sin, cos, asin = math.sin, math.cos, math.asin

local function Linear(t, b, c, d)
	return c * t / d + b
end

local function Smooth(t, b, c, d)
	t = t / d
	return c * t * t * (3 - 2 * t) + b
end

local function Smoother(t, b, c, d)
	t = t / d
	return c * t * t * t * (t * (6 * t - 15) + 10) + b
end

-- Arceusinator's Easing Functions
local function RevBack(t, b, c, d)
	t = 1 - t / d
	return c * (1 - (sin(t * 1.5707963267948965579989817342720925807952880859375) + (sin(t * 3.14159265358979311599796346854418516159057617187) * (cos(t * 3.14159265358979311599796346854418516159057617187) + 1) * 0.5))) + b
end

local function RidiculousWiggle(t, b, c, d)
	t = t / d
	return c * sin(sin(t * 3.14159265358979311599796346854418516159057617187) * 1.5707963267948965579989817342720925807952880859375) + b
end

-- YellowTide's Easing Functions
local function Spring(t, b, c, d)
	t = t / d
	return (1 + (-2.72 ^ (-6.9 * t) * cos(-20.1061929829746759423869661986827850341796875 * t))) * c + b
end

local function SoftSpring(t, b, c, d)
	t = t / d
	return (1 + (-2.72 ^ (-7.5 * t) * cos(-10.05309649148733797119348309934139251708984375 * t))) * c + b
end
-- End of YellowTide's functions

local function InQuad(t, b, c, d)
	t = t / d
	return c * t * t + b
end

local function OutQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function InOutQuad(t, b, c, d)
	t = t / d * 2
	return t < 1 and c * 0.5 * t * t + b or -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
end

local function OutInQuad(t, b, c, d)
	if t < d * 0.5 then
		t = 2 * t / d
		return -0.5 * c * t * (t - 2) + b
	else
		t, c = ((t * 2) - d) / d, 0.5 * c
		return c * t * t + b + c
	end
end

local function InCubic(t, b, c, d)
	t = t / d
	return c * t * t * t + b
end

local function OutCubic(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t + 1) + b
end

local function InOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t + 2) + b
	end
end

local function OutInCubic(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t + 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t + b + c
	end
end

local function InQuart(t, b, c, d)
	t = t / d
	return c * t * t * t * t + b
end

local function OutQuart(t, b, c, d)
	t = t / d - 1
	return -c * (t * t * t * t - 1) + b
end

local function InOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t + b
	else
		t = t - 2
		return -c * 0.5 * (t * t * t * t - 2) + b
	end
end

local function OutInQuart(t, b, c, d)
	if t < d * 0.5 then
		t, c = t * 2 / d - 1, c * 0.5
		return -c * (t * t * t * t - 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t * t + b + c
	end
end

local function InQuint(t, b, c, d)
	t = t / d
	return c * t * t * t * t * t + b
end

local function OutQuint(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t * t * t + 1) + b
end

local function InOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t * t * t + 2) + b
	end
end

local function OutInQuint(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t * t * t + 1) + b
	else
		t, c = ((t * 2) - d) / d, c * 0.5
		return c * t * t * t * t * t + b + c
	end
end

local function InSine(t, b, c, d)
	return -c * cos(t / d * 1.5707963267948965579989817342720925807952880859375) + c + b
end

local function OutSine(t, b, c, d)
	return c * sin(t / d * 1.5707963267948965579989817342720925807952880859375) + b
end

local function InOutSine(t, b, c, d)
	return -c * 0.5 * (cos(3.14159265358979311599796346854418516159057617187 * t / d) - 1) + b
end

local function OutInSine(t, b, c, d)
	c = c * 0.5
	return t < d * 0.5 and c * sin(t * 2 / d * 1.5707963267948965579989817342720925807952880859375) + b or -c * cos(((t * 2) - d) / d * 1.5707963267948965579989817342720925807952880859375) + 2 * c + b
end

local function InExpo(t, b, c, d)
	return t == 0 and b or c * 2 ^ (10 * (t / d - 1)) + b - c * 0.001
end

local function OutExpo(t, b, c, d)
	return t == d and b + c or c * 1.001 * (1 - 2 ^ (-10 * t / d)) + b
end

local function InOutExpo(t, b, c, d)
	t = t / d * 2
	return t == 0 and b or t == 2 and b + c or t < 1 and c * 0.5 * 2 ^ (10 * (t - 1)) + b - c * 0.0005 or c * 0.5 * 1.0005 * (2 - 2 ^ (-10 * (t - 1))) + b
end

local function OutInExpo(t, b, c, d)
	c = c * 0.5
	return t < d * 0.5 and (t * 2 == d and b + c or c * 1.001 * (1 - 2 ^ (-20 * t / d)) + b) or t * 2 - d == 0 and b + c or c * 2 ^ (10 * ((t * 2 - d) / d - 1)) + b + c - c * 0.001
end

local function InCirc(t, b, c, d)
	t = t / d
	return -c * ((1 - t * t) ^ 0.5 - 1) + b
end

local function OutCirc(t, b, c, d)
	t = t / d - 1
	return c * (1 - t * t) ^ 0.5 + b
end

local function InOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c * 0.5 * ((1 - t * t) ^ 0.5 - 1) + b
	else
		t = t - 2
		return c * 0.5 * ((1 - t * t) ^ 0.5 + 1) + b
	end
end

local function OutInCirc(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * (1 - t * t) ^ 0.5 + b
	else
		t = (t * 2 - d) / d
		return -c * ((1 - t * t) ^ 0.5 - 1) + b + c
	end
end

local function InElastic(t, b, c, d, a, p)
	t = t / d - 1
	p = p or d * 0.3
	return t == -1 and b or t == 0 and b + c or (not a or a < (c >= 0 and c or 0 - c)) and -(c * 2 ^ (10 * t) * sin((t * d - p * 0.25) * 6.28318530717958623199592693708837032318115234375 / p)) + b or -(a * 2 ^ (10 * t) * sin((t * d - p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)) * 6.28318530717958623199592693708837032318115234375 / p)) + b
end

local function OutElastic(t, b, c, d, a, p)
	t = t / d
	p = p or d * 0.3
	return t == 0 and b or t == 1 and b + c or (not a or a < (c >= 0 and c or 0 - c)) and c * 2 ^ (-10 * t) * sin((t * d - p * 0.25) * 6.28318530717958623199592693708837032318115234375 / p) + c + b or a * 2 ^ (-10 * t) * sin((t * d - p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)) * 6.28318530717958623199592693708837032318115234375 / p) + c + b
end

local function InOutElastic(t, b, c, d, a, p)
	if t == 0 then
		return b
	end

	t = t / d * 2 - 1

	if t == 1 then
		return b + c
	end

	p = p or d * 0.45
	a = a or 0

	local s

	if not a or a < (c >= 0 and c or 0 - c) then
		a = c
		s = p * 0.25
	else
		s = p / 6.28318530717958623199592693708837032318115234375 * asin(c / a)
	end

	if t < 1 then
		return -0.5 * a * 2 ^ (10 * t) * sin((t * d - s) * 6.28318530717958623199592693708837032318115234375 / p) + b
	else
		return a * 2 ^ (-10 * t) * sin((t * d - s) * 6.28318530717958623199592693708837032318115234375 / p ) * 0.5 + c + b
	end
end

local function OutInElastic(t, b, c, d, a, p)
	if t < d * 0.5 then
		return OutElastic(t * 2, b, c * 0.5, d, a, p)
	else
		return InElastic(t * 2 - d, b + c * 0.5, c * 0.5, d, a, p)
	end
end

local function InBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function OutBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function InOutBack(t, b, c, d, s)
	s = (s or 1.70158) * 1.525
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function OutInBack(t, b, c, d, s)
	c = c * 0.5
	s = s or 1.70158
	if t < d * 0.5 then
		t = (t * 2) / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	else
		t = ((t * 2) - d) / d
		return c * t * t * ((s + 1) * t - s) + b + c
	end
end

local function OutBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function InBounce(t, b, c, d)
	return c - OutBounce(d - t, 0, c, d) + b
end

local function InOutBounce(t, b, c, d)
	if t < d * 0.5 then
		return InBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return OutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
	end
end

local function OutInBounce(t, b, c, d)
	if t < d * 0.5 then
		return OutBounce(t * 2, b, c * 0.5, d)
	else
		return InBounce(t * 2 - d, b + c * 0.5, c * 0.5, d)
	end
end

return {
	[Enum.EasingDirection.In.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = InSine;
		[Enum.EasingStyle.Back.Name] = InBack;
		[Enum.EasingStyle.Quad.Name] = InQuad;
		[Enum.EasingStyle.Quart.Name] = InQuart;
		[Enum.EasingStyle.Quint.Name] = InQuint;
		[Enum.EasingStyle.Bounce.Name] = InBounce;
		[Enum.EasingStyle.Elastic.Name] = InElastic;
		[Enum.EasingStyle.Exponential.Name] = InExpo;
		[Enum.EasingStyle.Circular.Name] = InCirc;
		[Enum.EasingStyle.Cubic.Name] = InCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	[Enum.EasingDirection.Out.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = OutSine;
		[Enum.EasingStyle.Back.Name] = OutBack;
		[Enum.EasingStyle.Quad.Name] = OutQuad;
		[Enum.EasingStyle.Quart.Name] = OutQuart;
		[Enum.EasingStyle.Quint.Name] = OutQuint;
		[Enum.EasingStyle.Bounce.Name] = OutBounce;
		[Enum.EasingStyle.Elastic.Name] = OutElastic;
		[Enum.EasingStyle.Exponential.Name] = OutExpo;
		[Enum.EasingStyle.Circular.Name] = OutCirc;
		[Enum.EasingStyle.Cubic.Name] = OutCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	[Enum.EasingDirection.InOut.Name] = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = InOutSine;
		[Enum.EasingStyle.Back.Name] = InOutBack;
		[Enum.EasingStyle.Quad.Name] = InOutQuad;
		[Enum.EasingStyle.Quart.Name] = InOutQuart;
		[Enum.EasingStyle.Quint.Name] = InOutQuint;
		[Enum.EasingStyle.Bounce.Name] = InOutBounce;
		[Enum.EasingStyle.Elastic.Name] = InOutElastic;
		[Enum.EasingStyle.Exponential.Name] = InOutExpo;
		[Enum.EasingStyle.Circular.Name] = InOutCirc;
		[Enum.EasingStyle.Cubic.Name] = InOutCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};

	OutIn = {
		[Enum.EasingStyle.Linear.Name] = Linear;
		[Enum.EasingStyle.Sine.Name] = OutInSine;
		[Enum.EasingStyle.Back.Name] = OutInBack;
		[Enum.EasingStyle.Quad.Name] = OutInQuad;
		[Enum.EasingStyle.Quart.Name] = OutInQuart;
		[Enum.EasingStyle.Quint.Name] = OutInQuint;
		[Enum.EasingStyle.Bounce.Name] = OutInBounce;
		[Enum.EasingStyle.Elastic.Name] = OutInElastic;
		[Enum.EasingStyle.Exponential.Name] = OutInExpo;
		[Enum.EasingStyle.Circular.Name] = OutInCirc;
		[Enum.EasingStyle.Cubic.Name] = OutInCubic;
		Smooth = Smooth;
		Smoother = Smoother;
		RevBack = RevBack;
		RidiculousWiggle = RidiculousWiggle;
		Spring = Spring;
		SoftSpring = SoftSpring;
	};
}
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>